<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Error index - Proptest</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Usage documentation for the proptest and proptest-derive crates">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'visible';
            if (document.body.clientWidth < 500) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="../intro.html">Introduction</a></li><li><a href="../proptest/index.html"><strong aria-hidden="true">1.</strong> proptest</a></li><li><ol class="section"><li><a href="../proptest/getting-started.html"><strong aria-hidden="true">1.1.</strong> Getting started</a></li><li><a href="../proptest/tutorial/index.html"><strong aria-hidden="true">1.2.</strong> Understanding Proptest from the Bottom Up</a></li><li><ol class="section"><li><a href="../proptest/tutorial/strategy-basics.html"><strong aria-hidden="true">1.2.1.</strong> Strategy Basics</a></li><li><a href="../proptest/tutorial/shrinking-basics.html"><strong aria-hidden="true">1.2.2.</strong> Shrinking Basics</a></li><li><a href="../proptest/tutorial/test-runner.html"><strong aria-hidden="true">1.2.3.</strong> Using the Test Runner</a></li><li><a href="../proptest/tutorial/compound-strategies.html"><strong aria-hidden="true">1.2.4.</strong> Compound Strategies</a></li><li><a href="../proptest/tutorial/macro-proptest.html"><strong aria-hidden="true">1.2.5.</strong> The proptest! macro</a></li><li><a href="../proptest/tutorial/transforming-strategies.html"><strong aria-hidden="true">1.2.6.</strong> Transforming Strategies</a></li><li><a href="../proptest/tutorial/macro-prop-compose.html"><strong aria-hidden="true">1.2.7.</strong> The prop_compose! macro</a></li><li><a href="../proptest/tutorial/enums.html"><strong aria-hidden="true">1.2.8.</strong> Generating Enums</a></li><li><a href="../proptest/tutorial/filtering.html"><strong aria-hidden="true">1.2.9.</strong> Filtering</a></li><li><a href="../proptest/tutorial/recursive.html"><strong aria-hidden="true">1.2.10.</strong> Generating Recursive Data</a></li><li><a href="../proptest/tutorial/higher-order.html"><strong aria-hidden="true">1.2.11.</strong> Higher-Order Strategies</a></li><li><a href="../proptest/tutorial/arbitrary.html"><strong aria-hidden="true">1.2.12.</strong> Defining a Canonical Strategy for a Type</a></li><li><a href="../proptest/tutorial/config.html"><strong aria-hidden="true">1.2.13.</strong> Configuring Proptest</a></li></ol></li><li><a href="../proptest/failure-persistence.html"><strong aria-hidden="true">1.3.</strong> Failure Persistence</a></li><li><a href="../proptest/forking.html"><strong aria-hidden="true">1.4.</strong> Test Timeouts and Forking</a></li><li><a href="../proptest/no-std.html"><strong aria-hidden="true">1.5.</strong> no_std Support</a></li><li><a href="../proptest/wasm.html"><strong aria-hidden="true">1.6.</strong> Web Assembly Support</a></li><li><a href="../proptest/limitations.html"><strong aria-hidden="true">1.7.</strong> Limitations of Property Testing</a></li><li><a href="../proptest/vs-quickcheck.html"><strong aria-hidden="true">1.8.</strong> Proptest vs Quickcheck</a></li><li><a href="../proptest/reference-docs.html"><strong aria-hidden="true">1.9.</strong> Reference documentation</a></li></ol></li><li><a href="../proptest-derive/index.html"><strong aria-hidden="true">2.</strong> proptest-derive</a></li><li><ol class="section"><li><a href="../proptest-derive/getting-started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a></li><li><a href="../proptest-derive/modifiers.html"><strong aria-hidden="true">2.2.</strong> Modifier reference</a></li><li><a href="../proptest-derive/errors.html" class="active"><strong aria-hidden="true">2.3.</strong> Error index</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Proptest</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#error-index" id="error-index"><h1>Error Index</h1></a>
<a class="header" href="#e0001" id="e0001"><h2>E0001</h2></a>
<p>This error occurs when <code>#[derive(Arbitrary)]</code> is used on a type which has any
<a href="https://doc.rust-lang.org/stable/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-annotations-in-struct-definitions">lifetime parameters</a>. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo&lt;'a&gt; {
    bar: &amp;'a str,
}
#}</code></pre></pre>
<p>Due to the lack of <em><a href="https://github.com/rust-lang/rust/issues/44265">generic associated types (GATs)</a></em> on stable Rust,
it is currently impossible to define a <code>Strategy</code> which generates a type
that is lifetime-generic (e.g. <code>&amp;'a T</code>). Thus, proptest cannot implement
<code>Arbitrary</code> for such types either and therefore you cannot <code>#[derive(Arbitrary)]</code>
for such types. Once GATs are available, we will try to lift this restriction.
To follow the progress, consult the <a href="https://github.com/AltSysrq/proptest/issues/9">tracking issue</a> on the matter.</p>
<a class="header" href="#e0002" id="e0002"><h2>E0002</h2></a>
<p>This error occurs when <code>#[derive(Arbitrary)]</code> is used on a <code>union</code> type.
An example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
union IU32 {
    signed: i32,
    unsigned: u32,
}
#}</code></pre></pre>
<p>There are two main reasons for the error.</p>
<ol>
<li>
<p>It is not possible to <code>#[derive(Debug)]</code> on <code>union</code> types and manual
implementations cannot know which variant is valid so there are not
many valid implementations which are possible.</p>
</li>
<li>
<p>Second, we cannot mechanically tell which variant out of <code>signed</code> and
<code>unsigned</code> to generate. While we could allow you to tell the macro,
with an attribute such as <code>#[proptest(select)]</code> on the variant,
we have opted for a more conservative approach for the time being.
If you have a use case for <code>#[derive(Arbitrary)]</code> on <code>union</code> types,
please reach out on the <a href="https://github.com/altsysrq/proptest">issue tracker</a>.</p>
</li>
</ol>
<a class="header" href="#e0003" id="e0003"><h2>E0003</h2></a>
<p>This error occurs when <code>#[derive(Arbitrary)]</code> is used on a struct which
contains known <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#empty-types">uninhabited
types</a>. This
in turn means the struct itself is uninhabited and so it there is no sensible
<code>Arbitrary</code> implementation since values of the struct cannot be produced.</p>
<p>A trivial example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Uninhabited {
    inhabited: u32,
    never: !,
}
#}</code></pre></pre>
<p>Because there exist no values assignable to field <code>never</code>, it is also
impossible to construct an instance of struct <code>Uninhabited</code>.</p>
<p>Proptest’s ability to identify uninhabited types is limited. If it does not
recognise a particular type as uninhabited, the type will instead be assumed to
be inhabited and you will instead get an error about the type not implementing
<code>Arbitrary</code> trait.</p>
<a class="header" href="#e0004" id="e0004"><h2>E0004</h2></a>
<p>This error occurs when <code>#[derive(Arbitrary)]</code> is used on an enum with no
variants at all. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
enum Uninhabited {}
#}</code></pre></pre>
<p>Such an enum has no values at all, so it does not make sense to provide an
<code>Arbitrary</code> implementation for it since no values can be generated.</p>
<a class="header" href="#e0005" id="e0005"><h2>E0005</h2></a>
<p>This error occurs if <code>#[derive(Arbitrary)]</code> is used on an enum whose variants
are all uninhabited, using the same logic as described for <a href="#e0003"><code>E0003</code></a>.
As a result, the enum itself is totally uninhabited.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
enum Uninhabited {
    Never(!),
    NeverEver(!, !),
}
#}</code></pre></pre>
<a class="header" href="#e0006" id="e0006"><h2>E0006</h2></a>
<p>This error occurs if <code>#[derive(Arbitrary)]</code> is used on an enum where all
inhabited variants are marked with <a href="modifiers.html#skip"><code>#[proptest(skip)]</code></a>. In other words,
proptest is forbidden from generating any of the enum’s variants, and thus the
enum itself cannot be generated.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
enum MyEnum {
    // Ordinarily, proptest would be able to generate either of these variants,
    // but both are forbidden, so in the end proptest isn't allowed to generate
    // anything at all.
    #[proptest(skip)]
    UnitVariant,
    #[proptest(skip)]
    SimpleVariant(u32),
    // This variant is implicitly skipped because proptest knows it is
    // uninhabited.
    Uninhabited(!),
}
#}</code></pre></pre>
<a class="header" href="#e0007" id="e0007"><h2>E0007</h2></a>
<p>This error happens if an attribute <a href="modifiers.html#strategy"><code>#[proptest(strategy = &quot;expr&quot;)]</code></a> or
<a href="modifiers.html#value"><code>#[proptest(value = &quot;expr&quot;)]</code></a> is applied to the same item that has
<code>#[derive(Arbitrary)]</code>.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
#[proptest(value = &quot;MyStruct(42)&quot;)]
struct MyStruct(u32);
#}</code></pre></pre>
<p>This is rejected since nothing is being “derived” <em>per se</em>. A written out
implementation of <code>Arbitrary</code> should be used instead.</p>
<a class="header" href="#e0008" id="e0008"><h2>E0008</h2></a>
<p>This error happens if <a href="modifiers.html#skip"><code>#[proptest(skip)]</code></a> is applied to an unskippable item.
For example, struct fields cannot be skipped because Rust requires every field
of a struct to have a value.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct WidgetContainer {
    desired_widget_count: usize,
    #[proptest(skip)]
    widgets: Vec&lt;Widget&gt;,
}
#}</code></pre></pre>
<p>In general, the appropriate way to request proptest to not generate a field
value is to use <a href="modifiers.html#value"><code>#[proptest(value = &quot;expr&quot;)]</code></a> to provide a fixed value
yourself. For example, the above code could be properly written as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct WidgetContainer {
    desired_widget_count: usize,
    #[proptest(value = &quot;vec![]&quot;)] // Always generate an empty widget vec
    widgets: Vec&lt;Widget&gt;,
}
#}</code></pre></pre>
<a class="header" href="#e0009" id="e0009"><h2>E0009</h2></a>
<p>This error happens if <a href="modifiers.html#weight"><code>#[proptest(weight = &lt;integer&gt;)]</code></a> is applied to an item
where this does not make sense, such as a struct field. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Point {
    x: u32,
    #[proptest(weight = 42)]
    y: u32,
}
#}</code></pre></pre>
<p>The <code>weight</code> attribute only is sensible where proptest has a choice between
multiple items, i.e., enum variants. In contrast, with struct fields proptest
must provide a value for <em>every</em> field so there is no “this-or-that” choice.</p>
<a class="header" href="#e0010" id="e0010"><h2>E0010</h2></a>
<p>This error occurs if <a href="modifiers.html#params"><code>#[proptest(params = &quot;type&quot;)]</code></a> and/or
<a href="modifiers.html#no_params"><code>#[proptest(no_params)]</code></a> are set on both an item and its parent.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
#[proptest(params = &quot;String&quot;)]
struct Foo {
    #[proptest(no_params)]
    bar: String,
}
#}</code></pre></pre>
<p>If the parent item has any explicit parameter configuration, it totally defines
the parameters for the whole <code>Arbitrary</code> implementation and the child items
must work with that and cannot specify their own parameters.</p>
<a class="header" href="#e0011" id="e0011"><h2>E0011</h2></a>
<p>This error occurs if <a href="modifiers.html#params"><code>#[proptest(params = &quot;type&quot;)]</code></a> is set on a field but no
explicit strategy is configured with <a href="modifiers.html#strategy"><code>#[proptest(strategy = &quot;expr&quot;)]</code></a> or
another such modifier. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo {
    #[proptest(param = &quot;u8&quot;)]
    some_string: String,
}
#}</code></pre></pre>
<p>This example illustrates why both must be specified: <code>String</code>‘s arbitrary
implementation takes a <code>proptest::string::StringParam</code>, but here we try to pass
it a <code>u8</code>.</p>
<p>While the generated code could work if the type given by <code>param</code> is the same as
that for the default strategy, there would be no purpose in specifying the
parameter type by hand; therefore specifying only <code>param</code> is in all cases
forbidden.</p>
<a class="header" href="#e0012" id="e0012"><h2>E0012</h2></a>
<p>This error occurs if <a href="modifiers.html#filter"><code>#[proptest(filter = &quot;expr&quot;)]</code></a> is set on an item, but the
item containing it specifies a direct way to generate the whole value, which
would thus occur without consulting the filter.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
enum Foo {
    #[proptest(value = &quot;Foo::Bar(42)&quot;)]
    Bar {
        #[proptest(filter = &quot;is_even&quot;)]
        even_number: u32,
    },
    // ...
}
#}</code></pre></pre>
<p>In this example, the entire <code>Bar</code> variant specifies how to generate itself
wholesale. As a result, the <code>filter</code> clause on <code>even_number</code> has no opportunity
to run.</p>
<a class="header" href="#e0013" id="e0013"><h2>E0013</h2></a>
<p>This error would occur if an outer attribute of the form <code>#![proptest(..)]</code>
were applied to something underneath a <code>#[derive(Arbitrary)]</code>.</p>
<p>As of Rust 1.30.0, there are no known ways to produce this error since the Rust
compiler will reject the attribute first.</p>
<a class="header" href="#e0014" id="e0014"><h2>E0014</h2></a>
<p>This error occurs if a bare <code>#[proptest]</code> attribute is applied to anything,
since it has no meaningful content.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo {
    #[proptest]
    field: u8,
}
#}</code></pre></pre>
<p>The only legal use of the attribute is the form <code>#[proptest(..)]</code>.</p>
<a class="header" href="#e0015" id="e0015"><h2>E0015</h2></a>
<p>This error occurs if an attribute of the form <code>#[proptest = value]</code> is
encountered in any context.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo {
    #[proptest = 1234]
    field: u8,
}
#}</code></pre></pre>
<a class="header" href="#e0016" id="e0016"><h2>E0016</h2></a>
<p>This error occurs if a literal (as opposed to <code>key = value</code>) is passed inside
<code>#[proptest(..)]</code> in any context.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo {
    #[proptest(1234)]
    field: u8,
}
#}</code></pre></pre>
<a class="header" href="#e0017" id="e0017"><h2>E0017</h2></a>
<p>This error occurs if any modifier of <code>#[proptest(..)]</code> is set more than once on
the same item.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
#[proptest(no_params, no_params)]
struct Foo(u32);
#}</code></pre></pre>
<a class="header" href="#e0018" id="e0018"><h2>E0018</h2></a>
<p>This error occurs if an unknown modifier is passed in <code>#[proptest(..)]</code>.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
#[proptest(frobnicate = &quot;true&quot;)]
struct Foo(u32);
#}</code></pre></pre>
<p>Please see the <a href="modifiers.html">modifiers reference</a> to see what modifiers are
available.</p>
<a class="header" href="#e0019" id="e0019"><h2>E0019</h2></a>
<p>This error happens if anything extra is passed to <a href="modifiers.html#no_params"><code>#[proptest(no_params)]</code></a>.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
#[proptest(no_params = &quot;true&quot;)]
struct Foo(u32);
#}</code></pre></pre>
<p><code>no_params</code> takes no configuration. The correct form is simply
<code>#[proptest(no_params)]</code>.</p>
<a class="header" href="#e0020" id="e0020"><h2>E0020</h2></a>
<p>This error happens if anything extra is passed to <a href="modifiers.html#skip"><code>#[proptest(skip)]</code></a>.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
enum Foo {
    Small,
    #[proptest(skip = &quot;yes&quot;)]
    Huge(ExpensiveType),
}
#}</code></pre></pre>
<p><code>skip</code> takes no configuration. The correct form is simply <code>#[proptest(skip)]</code>.</p>
<a class="header" href="#e0021" id="e0021"><h2>E0021</h2></a>
<p>This error happens if <a href="modifiers.html#weight"><code>#[proptest(weight = &lt;integer&gt;)]</code></a> is passed an invalid
integer or passed nothing at all.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
enum Foo {
    #[proptest(weight)]
    V1,
    #[proptest(weight = heavy)]
    V2,
}
#}</code></pre></pre>
<p>The only acceptable form is <code>#[proptest(weight = &lt;integer&gt;)]</code>, where
<code>&lt;integer&gt;</code> is either an integer literal which fits in a <code>u32</code> or the same but
enclosed in quotation marks.</p>
<a class="header" href="#e0022" id="e0022"><h2>E0022</h2></a>
<p>This error occurs if more than one of <a href="modifiers.html#no_params"><code>#[proptest(no_params)]</code></a> and
<a href="modifiers.html#params"><code>#[proptest(params = &quot;type&quot;)]</code></a> are applied to the same item.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
#[proptest(no_params, params = &quot;u8&quot;)]
struct Foo(u32);
#}</code></pre></pre>
<p>One attribute or the other must be picked depending on desired effect.</p>
<a class="header" href="#e0023" id="e0023"><h2>E0023</h2></a>
<p>This error happens if an invalid <a href="modifiers.html#params"><code>#[proptest(params = &quot;type&quot;)]</code></a> attribute is
applied to an item.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
#[proptest(params = &quot;Vec&lt;u8&quot;)] // Note missing '&gt;'
struct Foo(u32);
#}</code></pre></pre>
<p>There are a few different ways to get this error:</p>
<ul>
<li>
<p>Pass nothing at all. E.g., <code>#[proptest(params)]</code>.</p>
</li>
<li>
<p>Pass something other than a string as the value. E.g.,
<code>#[proptest(params = 42)]</code>.</p>
</li>
<li>
<p>Pass a malformed type in the string, as in the example above. (See also
<a href="#valid-rust-syntax">caveat on syntax</a>.)</p>
</li>
</ul>
<a class="header" href="#e0024" id="e0024"><h2>E0024</h2></a>
<p>This error happens if an invalid <code>#[proptest ..]</code> attribute is applied using a
syntax the <code>proptest-derive</code> crate is not prepared to handle.</p>
<p>Exactly what conditions can produce this error vary by Rust version.</p>
<a class="header" href="#e0025" id="e0025"><h2>E0025</h2></a>
<p>This error happens if more than one of <a href="modifiers.html#strategy"><code>#[proptest(strategy = &quot;expr&quot;)]</code></a>,
<a href="modifiers.html#value"><code>#[proptest(value = &quot;expr&quot;)]</code></a>, or <a href="modifiers.html#regex"><code>#[proptest(regex = &quot;string&quot;)]</code></a> are applied
to the same item.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo {
    #[proptest(value = &quot;42&quot;, strategy = &quot;Just(56)&quot;)]
    bar: u32,
}
#}</code></pre></pre>
<p>Each of these modifiers completely describe how to generate the value, so they
cannot both be applied to the same thing. One or the other must be chosen
depending on the desired effect.</p>
<a class="header" href="#e0026" id="e0026"><h2>E0026</h2></a>
<p>This error happens if an invalid form of <a href="modifiers.html#strategy"><code>#[proptest(strategy = &quot;expr&quot;)]</code></a> or
<a href="modifiers.html#value"><code>#[proptest(value = &quot;expr&quot;)]</code></a> is used.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo {
    #[proptest(value = &quot;3↑↑↑↑3&quot;)] // String content is not valid Rust syntax
    g1: u128,
}
#}</code></pre></pre>
<p>There are a few different ways to get this error:</p>
<ul>
<li>
<p>Pass nothing at all. E.g., <code>#[proptest(value)]</code>.</p>
</li>
<li>
<p>Use another illegal form. E.g., <code>#[proptest(value(&quot;a&quot;, &quot;b&quot;))]</code>.</p>
</li>
<li>
<p>Pass a string expression which is not valid Rust syntax, as in the above
example. (See also <a href="#valid-rust-syntax">caveat on syntax</a>.)</p>
</li>
</ul>
<a class="header" href="#e0027" id="e0027"><h2>E0027</h2></a>
<p>This error happens if an invalid form of <a href="modifiers.html#filter"><code>#[proptest(filter = &quot;expr&quot;)]</code></a> is
used.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo {
    #[proptest(filter = &quot;&gt; 3&quot;)] // String content is not an expression
    big_number: u128,
}
#}</code></pre></pre>
<p>There are a few different ways to get this error:</p>
<ul>
<li>
<p>Pass nothing at all. E.g., <code>#[proptest(filter)]</code>.</p>
</li>
<li>
<p>Use another illegal form. E.g., <code>#[proptest(filter(&quot;a&quot;, &quot;b&quot;))]</code>.</p>
</li>
<li>
<p>Pass a string expression which is not valid Rust syntax, as in the above
example. (See also <a href="#valid-rust-syntax">caveat on syntax</a>.)</p>
</li>
</ul>
<a class="header" href="#e0028" id="e0028"><h2>E0028</h2></a>
<p>This error occurs if a modifier which implies a value is to be generated is
applied to an enum variant which is also marked <a href="modifiers.html#skip"><code>#[proptest(skip)]</code></a>.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
enum Enum {
    V1(u32),
    #[proptest(skip, value = &quot;Enum::V2(42)&quot;)]
    V2(u32),
}
#}</code></pre></pre>
<p>Here, the <a href="modifiers.html#value"><code>#[proptest(value = &quot;expr&quot;)]</code></a> modifier suggests the user intends
some value to be generated for the enum variant, but at the same time
<a href="modifiers.html#skip"><code>#[proptest(skip)]</code></a> indicates not to generate that variant.</p>
<a class="header" href="#e0029" id="e0029"><h2>E0029</h2></a>
<p>This error happens if a modifier which would constrain or control how the value
of an enum variant is to be generated is applied to a unit variant.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
enum Foo {
    #[proptest(value = &quot;Foo::V1&quot;)]
    UnitVariant,
    // ...
}
#}</code></pre></pre>
<p>Unit variants only have one possible value, so there is only one possible
strategy. As a result, it is pointless to try to specify an alternate strategy
or to filter such variants.</p>
<a class="header" href="#e0030" id="e0030"><h2>E0030</h2></a>
<p>This error happens if a modifier which would constrain or control how the value
of a struct is to be generated is applied to a unit struct.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
#[proptest(params = &quot;u8&quot;)]
struct UnitStruct;
#}</code></pre></pre>
<p>Unit structs only have one possible value, so there is only one possible
strategy. As a result, it is pointless to try to specify an alternate strategy
or to filter such structs.</p>
<a class="header" href="#e0031" id="e0031"><h2>E0031</h2></a>
<p>This error occurs if <a href="modifiers.html#no_bound"><code>#[proptest(no_bound)]</code></a> is applied to something that is
not a type variable.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo {
    #[proptest(no_bound)]
    bar: u32,
}
#}</code></pre></pre>
<p>The <code>no_bound</code> modifier only makes sense on generic type variables, as in</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo&lt;#[proptest(no_bound)] T&gt; {
    #[proptest(value = &quot;None&quot;)]
    bar: Option&lt;T&gt;,
}
#}</code></pre></pre>
<a class="header" href="#e0032" id="e0032"><h2>E0032</h2></a>
<p>This error happens if <a href="modifiers.html#no_bound"><code>#[proptest(no_bound)]</code></a> is passed anything.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
struct Foo&lt;#[proptest(no_bound = &quot;yes&quot;)] T&gt; {
    _bar: PhantomData&lt;T&gt;,
}
#}</code></pre></pre>
<p>The only valid form for the modifier is <code>#[proptest(no_bound)]</code>.</p>
<a class="header" href="#e0033" id="e0033"><h2>E0033</h2></a>
<p>This error occurs if the sum of the weights on the variants of an enum overflow
a <code>u32</code>.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Arbitrary)]
enum Foo {
    #[proptest(weight = 3_000_000_000)]
    ThreeFifths,
    #[proptest(weight = 2_000_000_000)]
    TwoFifths,
}
#}</code></pre></pre>
<p>The only solution is to reduce the magnitude of the weights so that their sum
fits in a <code>u32</code>. Keep in mind that variants without a <code>weight</code> modifier still
effectively have <code>#[proptest(weight = 1)]</code>.</p>
<a class="header" href="#e0034" id="e0034"><h2>E0034</h2></a>
<p>This error occurs if <a href="modifiers.html#regex"><code>#[proptest(regex = &quot;string&quot;)]</code></a> is used with invalid
syntax.</p>
<p>The most common forms are <code>#[proptest(regex = &quot;string-regex&quot;)]</code> and
<code>#[proptest(regex(&quot;string-regex&quot;))]</code>.</p>
<a class="header" href="#e0035" id="e0035"><h2>E0035</h2></a>
<p>This error occurs if both <a href="modifiers.html#regex"><code>#[proptest(regex = &quot;string&quot;)]</code></a> and
<a href="modifiers.html#params"><code>#[proptest(params = &quot;type&quot;)]</code></a> are applied to the same item.</p>
<p>Values generated via regular expression take no parameters so the <code>params</code>
modifier would be meaningless.</p>
<a class="header" href="#valid-rust-syntax" id="valid-rust-syntax"><h2>“Valid Rust syntax”</h2></a>
<p>The definition of “valid Rust syntax” in various string modifiers is determined
by the <code>syn</code> crate. If valid syntax is rejected, you can work around it in a
couple ways depending on what the syntax is describing:</p>
<p>For types, simply define a type alias for the type in question. For example,</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type RetroBox = ~str; // N.B. &quot;~str&quot; is not valid Rust 1.30 syntax

//...
#[derive(Debug, Arbitrary)]
#[proptest(params = &quot;RetroBox&quot;)]
struct MyStruct { /* ... */ }
#}</code></pre></pre>
<p>For values, you can generally factor the code into a constant or function. For
example,</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// N.B. Rust 1.30 does not have an exponentiation operator.
const PI_SQUARED: f64 = PI ** 2.0;

//...
#[derive(Debug, Arbitrary)]
struct MyStruct {
    #[proptest(value = &quot;PI_SQUARED&quot;)]
    factor: f64,
}
#}</code></pre></pre>
<p>If you need to implement such a work around, consider also <a href="https://github.com/altsysrq/proptest/issues">filing an
issue</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../proptest-derive/modifiers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../proptest-derive/modifiers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
