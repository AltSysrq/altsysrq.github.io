var searchIndex = {};
searchIndex["proptest"] = {"doc":"Proptest is a property testing framework (i.e., the QuickCheck family) inspired by the Hypothesis framework for Python. It allows to test that certain properties of your code hold for arbitrary inputs, and if a failure is found, automatically finds the minimal test case to reproduce the problem. Unlike QuickCheck, generation and shrinking is defined on a per-value basis instead of per-type, which makes it more flexible and simplifies composition.","items":[[0,"arbitrary","proptest","Defines the [`Arbitrary`] trait and related free functions and type aliases. See the trait for more information.",null,null],[5,"any","proptest::arbitrary","Generates a [`Strategy`] producing [`Arbitrary`][trait Arbitrary] values of `A`. Unlike [`arbitrary`][fn arbitrary], it should be used for being explicit on what `A` is. For clarity, this may be a good idea.",null,{"o":{"n":"strategyfor"}}],[5,"any_with","","Generates a [`Strategy`] producing [`Arbitrary`] values of `A` with the given configuration arguments passed in `args`. Unlike [`arbitrary_with`], it should be used for being explicit on what `A` is. For clarity, this may be a good idea.",null,{"i":[{"n":"paramsfor"}],"o":{"n":"strategyfor"}}],[5,"arbitrary","","Generates a [`Strategy`] producing [`Arbitrary`] values of `A`. Works better with type inference than [`any::<A>()`].",null,{"o":{"n":"s"}}],[5,"arbitrary_with","","Generates a [`Strategy`] producing [`Arbitrary`] values of `A` with the given configuration arguments passed in `args`. Works better with type inference than [`any_with::<A>(args)`].",null,{"i":[{"n":"p"}],"o":{"n":"s"}}],[0,"functor","","Provides higher order `Arbitrary` traits. This is mainly for use by `proptest_derive`.",null,null],[8,"ArbitraryF1","proptest::arbitrary::functor","`ArbitraryF1` lets you lift a [`Strategy`] to unary type constructors such as `Box`, `Vec`, and `Option`.",null,null],[16,"Parameters","","The type of parameters that [`lift1_with`] accepts for configuration of the lifted and generated [`Strategy`]. Parameters must implement [`Default`].",0,null],[11,"lift1","","Lifts a given [`Strategy`] to a new [`Strategy`] for the (presumably) bigger type. This is useful for lifting a `Strategy` for `SomeType` to a container such as `Vec<SomeType>`.",0,{"i":[{"n":"as"}],"o":{"n":"boxedstrategy"}}],[10,"lift1_with","","Lifts a given [`Strategy`] to a new [`Strategy`] for the (presumably) bigger type. This is useful for lifting a `Strategy` for `SomeType` to a container such as `Vec` of `SomeType`. The composite strategy is passed the arguments given in `args`.",0,null],[8,"ArbitraryF2","","`ArbitraryF2` lets you lift [`Strategy`] to binary type constructors such as `Result`, `HashMap`.",null,null],[16,"Parameters","","The type of parameters that [`lift2_with`] accepts for configuration of the lifted and generated [`Strategy`]. Parameters must implement [`Default`].",1,null],[11,"lift2","","Lifts two given strategies to a new [`Strategy`] for the (presumably) bigger type. This is useful for lifting a `Strategy` for `Type1` and one for `Type2` to a container such as `HashMap<Type1, Type2>`.",1,{"i":[{"n":"as"},{"n":"bs"}],"o":{"n":"boxedstrategy"}}],[10,"lift2_with","","Lifts two given strategies to a new [`Strategy`] for the (presumably) bigger type. This is useful for lifting a `Strategy` for `Type1` and one for `Type2` to a container such as `HashMap<Type1, Type2>`. The composite strategy is passed the arguments given in `args`.",1,null],[6,"StrategyFor","proptest::arbitrary","`StrategyFor` allows you to mention the type of [`Strategy`] for the input type `A` without directly using associated types or without resorting to existential types. This way, if implementation of [`Arbitrary`] changes, your tests should not break. This can be especially beneficial when the type of `Strategy` that you are dealing with is very long in name (the case with generics).",null,null],[6,"ParamsFor","","`ParamsFor` allows you to mention the type of [`Parameters`] for the input type `A` without directly using associated types or without resorting to existential types. This way, if implementation of [`Arbitrary`] changes, your tests should not break.",null,null],[6,"SMapped","","A static map from a strategy of `I` to `O`.",null,null],[6,"Mapped","","A normal map from a strategy of `I` to `O`.",null,null],[8,"Arbitrary","","Arbitrary determines a canonical [`Strategy`] for the implementing type.",null,null],[16,"Parameters","","The type of parameters that [`arbitrary_with`] accepts for configuration of the generated [`Strategy`]. Parameters must implement [`Default`].",2,null],[11,"arbitrary","","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`).",2,null],[10,"arbitrary_with","","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`). The strategy is passed the arguments given in args.",2,null],[16,"Strategy","","The type of [`Strategy`] used to generate values of type `Self`.",2,null],[0,"array","proptest","Support for strategies producing fixed-length arrays.",null,null],[3,"UniformArrayStrategy","proptest::array","A `Strategy` which generates fixed-size arrays containing values drawn from an inner strategy.",null,null],[3,"ArrayValueTree","","A `ValueTree` operating over a fixed-size array.",null,null],[5,"uniform1","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform2","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform3","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform4","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform5","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform6","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform7","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform8","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform9","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform10","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform11","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform12","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform13","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform14","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform15","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform16","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform17","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform18","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform19","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform20","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform21","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform22","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform23","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform24","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform25","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform26","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform27","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform28","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform29","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform30","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform31","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[5,"uniform32","","Create a strategy to generate fixed-length arrays.",null,{"i":[{"n":"s"}],"o":{"n":"uniformarraystrategy"}}],[11,"clone","","",3,{"i":[{"n":"self"}],"o":{"n":"uniformarraystrategy"}}],[11,"fmt","","",3,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Directly create a `UniformArrayStrategy`.",3,{"i":[{"n":"s"}],"o":{"n":"self"}}],[11,"clone","","",4,{"i":[{"n":"self"}],"o":{"n":"arrayvaluetree"}}],[11,"fmt","","",4,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"new_tree","","",3,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",4,null],[11,"simplify","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",4,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"bits","proptest","Strategies for working with bit sets.",null,null],[3,"BitSetStrategy","proptest::bits","Generates values as a set of bits between the two bounds.",null,null],[3,"SampledBitSetStrategy","","Generates bit sets with a particular number of bits set.",null,null],[3,"BitSetValueTree","","Value tree produced by `BitSetStrategy` and `SampledBitSetStrategy`.",null,null],[0,"u8","","",null,null],[5,"between","proptest::bits::u8","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["u8"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"u8"}],"o":{"g":["u8"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[17,"ANY","","Generates integers where all bits may be set.",null,null],[0,"u16","proptest::bits","",null,null],[5,"between","proptest::bits::u16","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["u16"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"u16"}],"o":{"g":["u16"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[17,"ANY","","Generates integers where all bits may be set.",null,null],[0,"u32","proptest::bits","",null,null],[5,"between","proptest::bits::u32","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["u32"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"u32"}],"o":{"g":["u32"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[17,"ANY","","Generates integers where all bits may be set.",null,null],[0,"u64","proptest::bits","",null,null],[5,"between","proptest::bits::u64","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["u64"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"u64"}],"o":{"g":["u64"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[17,"ANY","","Generates integers where all bits may be set.",null,null],[0,"i8","proptest::bits","",null,null],[5,"between","proptest::bits::i8","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["i8"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"i8"}],"o":{"g":["i8"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[17,"ANY","","Generates integers where all bits may be set.",null,null],[0,"i16","proptest::bits","",null,null],[5,"between","proptest::bits::i16","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["i16"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"i16"}],"o":{"g":["i16"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[17,"ANY","","Generates integers where all bits may be set.",null,null],[0,"i32","proptest::bits","",null,null],[5,"between","proptest::bits::i32","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["i32"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"i32"}],"o":{"g":["i32"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[17,"ANY","","Generates integers where all bits may be set.",null,null],[0,"i64","proptest::bits","",null,null],[5,"between","proptest::bits::i64","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["i64"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"i64"}],"o":{"g":["i64"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[17,"ANY","","Generates integers where all bits may be set.",null,null],[0,"usize","proptest::bits","",null,null],[5,"between","proptest::bits::usize","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["usize"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"usize"}],"o":{"g":["usize"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[0,"isize","proptest::bits","",null,null],[5,"between","proptest::bits::isize","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["isize"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"isize"}],"o":{"g":["isize"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[0,"bitset","proptest::bits","",null,null],[5,"between","proptest::bits::bitset","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["bitset"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"n":"bitset"}],"o":{"g":["bitset"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[0,"bool_vec","proptest::bits","",null,null],[5,"between","proptest::bits::bool_vec","Generates values where bits between the given bounds may be set.",null,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"g":["vec"],"n":"bitsetstrategy"}}],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",null,{"i":[{"g":["bool"],"n":"vec"}],"o":{"g":["vec"],"n":"bitsetstrategy"}}],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",null,null],[8,"BitSetLike","proptest::bits","Trait for types which can be handled with `BitSetStrategy`.",null,null],[10,"new_bitset","","Create a new value of `Self` with space for up to `max` bits, all initialised to zero.",5,{"i":[{"n":"usize"}],"o":{"n":"self"}}],[10,"len","","Return an upper bound on the greatest bit set plus one.",5,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[10,"test","","Test whether the given bit is set.",5,{"i":[{"n":"self"},{"n":"usize"}],"o":{"n":"bool"}}],[10,"set","","Set the given bit.",5,{"i":[{"n":"self"},{"n":"usize"}]}],[10,"clear","","Clear the given bit.",5,{"i":[{"n":"self"},{"n":"usize"}]}],[11,"count","","Return the number of bits set.",5,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"clone","","",6,{"i":[{"n":"self"}],"o":{"n":"bitsetstrategy"}}],[11,"fmt","","",6,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Create a strategy which generates values where bits between `min` (inclusive) and `max` (exclusive) may be set.",6,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"n":"self"}}],[11,"masked","","Create a strategy which generates values where any bits set (and only those bits) in `mask` may be set.",6,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"new_tree","","",6,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",7,{"i":[{"n":"self"}],"o":{"n":"sampledbitsetstrategy"}}],[11,"fmt","","",7,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",7,null],[11,"new_tree","","",7,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",8,{"i":[{"n":"self"}],"o":{"n":"bitsetvaluetree"}}],[11,"fmt","","",8,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"current","","",8,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"simplify","","",8,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",8,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"bool","proptest","Strategies for generating `bool` values.",null,null],[3,"Any","proptest::bool","The type of the `ANY` constant.",null,null],[3,"Weighted","","The return type from `weighted()`.",null,null],[3,"BoolValueTree","","The `ValueTree` to shrink booleans to false.",null,null],[5,"weighted","","Generates boolean values by picking `true` with the given `probability` (1.0 = always true, 0.0 = always false).",null,{"i":[{"n":"f64"}],"o":{"n":"weighted"}}],[17,"ANY","","Generates boolean values by picking `true` or `false` uniformly.",null,null],[11,"clone","","",9,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",9,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",9,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",10,{"i":[{"n":"self"}],"o":{"n":"weighted"}}],[11,"fmt","","",10,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",10,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",11,{"i":[{"n":"self"}],"o":{"n":"boolvaluetree"}}],[11,"fmt","","",11,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"current","","",11,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"simplify","","",11,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",11,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"char","proptest","Strategies for generating `char` values.",null,null],[3,"CharStrategy","proptest::char","Strategy for generating `char`s.",null,null],[3,"CharValueTree","","The `ValueTree` corresponding to `CharStrategy`.",null,null],[5,"select_char","","Selects a random character the way `CharStrategy` does.",null,null],[5,"any","","Creates a `CharStrategy` which picks from literally any character, with the default biases.",null,{"o":{"n":"charstrategy"}}],[5,"range","","Creates a `CharStrategy` which selects characters within the given endpoints, inclusive, using the default biases.",null,{"i":[{"n":"char"},{"n":"char"}],"o":{"n":"charstrategy"}}],[5,"ranges","","Creates a `CharStrategy` which selects characters within the given ranges, all inclusive, using the default biases.",null,{"i":[{"n":"cow"}],"o":{"n":"charstrategy"}}],[17,"DEFAULT_SPECIAL_CHARS","","A default set of characters to consider as \"special\" during character generation.",null,null],[17,"DEFAULT_PREFERRED_RANGES","","A default sequence of ranges used preferentially when generating random characters.",null,null],[11,"fmt","","",12,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",12,{"i":[{"n":"self"}],"o":{"n":"charstrategy"}}],[11,"new","","Construct a new `CharStrategy` with the parameters it will pass to the function underlying `select_char()`.",12,{"i":[{"n":"cow"},{"n":"cow"},{"n":"cow"}],"o":{"n":"self"}}],[11,"new_borrowed","","Same as `CharStrategy::new()` but using `Cow::Borrowed` for all parts.",12,null],[11,"fmt","","",13,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",13,{"i":[{"n":"self"}],"o":{"n":"charvaluetree"}}],[11,"new_tree","","",12,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",13,{"i":[{"n":"self"}],"o":{"n":"char"}}],[11,"simplify","","",13,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",13,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"collection","proptest","Strategies for generating `std::collections` of values.",null,null],[3,"SizeRange","proptest::collection","The minimum and maximum range/bounds on the size of a collection. The interval must form a subset of `[0, std::usize::MAX]`.",null,null],[3,"VecStrategy","","Strategy to create `Vec`s with a length in a certain range.",null,null],[3,"VecDequeStrategy","","Strategy to create `VecDeque`s with a length in a certain range.",null,null],[3,"VecDequeValueTree","","`ValueTree` corresponding to `VecDequeStrategy`.",null,null],[3,"LinkedListStrategy","","Strategy to create `LinkedList`s with a length in a certain range.",null,null],[3,"LinkedListValueTree","","`ValueTree` corresponding to `LinkedListStrategy`.",null,null],[3,"BinaryHeapStrategy","","Strategy to create `BinaryHeap`s with a length in a certain range.",null,null],[3,"BinaryHeapValueTree","","`ValueTree` corresponding to `BinaryHeapStrategy`.",null,null],[3,"HashSetStrategy","","Strategy to create `HashSet`s with a length in a certain range.",null,null],[3,"HashSetValueTree","","`ValueTree` corresponding to `HashSetStrategy`.",null,null],[3,"BTreeSetStrategy","","Strategy to create `BTreeSet`s with a length in a certain range.",null,null],[3,"BTreeSetValueTree","","`ValueTree` corresponding to `BTreeSetStrategy`.",null,null],[3,"HashMapStrategy","","Strategy to create `HashMap`s with a length in a certain range.",null,null],[3,"HashMapValueTree","","`ValueTree` corresponding to `HashMapStrategy`.",null,null],[3,"BTreeMapStrategy","","Strategy to create `BTreeMap`s with a length in a certain range.",null,null],[3,"BTreeMapValueTree","","`ValueTree` corresponding to `BTreeMapStrategy`.",null,null],[3,"VecValueTree","","`ValueTree` corresponding to `VecStrategy`.",null,null],[5,"size_range","","Creates a `SizeRange` from some value that is convertible into it.",null,null],[5,"vec","","Create a strategy to generate `Vec`s containing elements drawn from `element` and with a size range given by `size`.",null,null],[5,"vec_deque","","Create a strategy to generate `VecDeque`s containing elements drawn from `element` and with a size range given by `size`.",null,null],[5,"linked_list","","Create a strategy to generate `LinkedList`s containing elements drawn from `element` and with a size range given by `size`.",null,null],[5,"binary_heap","","Create a strategy to generate `BinaryHeap`s containing elements drawn from `element` and with a size range given by `size`.",null,null],[5,"hash_set","","Create a strategy to generate `HashSet`s containing elements drawn from `element` and with a size range given by `size`.",null,null],[5,"btree_set","","Create a strategy to generate `BTreeSet`s containing elements drawn from `element` and with a size range given by `size`.",null,null],[5,"hash_map","","Create a strategy to generate `HashMap`s containing keys and values drawn from `key` and `value` respectively, and with a size within the given range.",null,null],[5,"btree_map","","Create a strategy to generate `BTreeMap`s containing keys and values drawn from `key` and `value` respectively, and with a size within the given range.",null,null],[11,"default","","Constructs a `SizeRange` equivalent to `size_range(0..100)`.",14,{"o":{"n":"self"}}],[11,"new","","Creates a `SizeBounds` from a `RangeInclusive<usize>`.",14,{"i":[{"g":["usize"],"n":"rangeinclusive"}],"o":{"n":"self"}}],[11,"with","","Merges self together with some other argument producing a product type expected by some impelementations of `A: Arbitrary` in `A::Parameters`. This can be more ergonomic to work with and may help type inference.",14,null],[11,"lift","","Merges self together with some other argument generated with a default value producing a product type expected by some impelementations of `A: Arbitrary` in `A::Parameters`. This can be more ergonomic to work with and may help type inference.",14,null],[11,"from","","",14,null],[11,"from","","",14,{"i":[{"n":"usize"}],"o":{"n":"self"}}],[11,"from","","",14,{"i":[{"g":["usize"],"n":"rangeto"}],"o":{"n":"self"}}],[11,"from","","",14,{"i":[{"g":["usize"],"n":"range"}],"o":{"n":"self"}}],[11,"from","","",14,{"i":[{"g":["usize"],"n":"rangeinclusive"}],"o":{"n":"self"}}],[11,"from","","",14,{"i":[{"g":["usize"],"n":"rangetoinclusive"}],"o":{"n":"self"}}],[11,"add","","",14,null],[11,"clone","","",14,{"i":[{"n":"self"}],"o":{"n":"sizerange"}}],[11,"eq","","",14,{"i":[{"n":"self"},{"n":"sizerange"}],"o":{"n":"bool"}}],[11,"ne","","",14,{"i":[{"n":"self"},{"n":"sizerange"}],"o":{"n":"bool"}}],[11,"hash","","",14,null],[11,"fmt","","",14,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",15,{"i":[{"n":"self"}],"o":{"n":"vecstrategy"}}],[11,"fmt","","",15,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",16,{"i":[{"n":"self"}],"o":{"n":"vecdequestrategy"}}],[11,"fmt","","",16,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",17,{"i":[{"n":"self"}],"o":{"n":"vecdequevaluetree"}}],[11,"fmt","","",17,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",16,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",17,null],[11,"simplify","","",17,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",17,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",18,{"i":[{"n":"self"}],"o":{"n":"linkedliststrategy"}}],[11,"fmt","","",18,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",19,{"i":[{"n":"self"}],"o":{"n":"linkedlistvaluetree"}}],[11,"fmt","","",19,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",18,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",19,null],[11,"simplify","","",19,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",19,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",20,{"i":[{"n":"self"}],"o":{"n":"binaryheapstrategy"}}],[11,"fmt","","",20,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",21,{"i":[{"n":"self"}],"o":{"n":"binaryheapvaluetree"}}],[11,"fmt","","",21,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",20,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",21,null],[11,"simplify","","",21,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",21,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",22,{"i":[{"n":"self"}],"o":{"n":"hashsetstrategy"}}],[11,"fmt","","",22,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",23,{"i":[{"n":"self"}],"o":{"n":"hashsetvaluetree"}}],[11,"fmt","","",23,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",22,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",23,null],[11,"simplify","","",23,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",23,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",24,{"i":[{"n":"self"}],"o":{"n":"btreesetstrategy"}}],[11,"fmt","","",24,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",25,{"i":[{"n":"self"}],"o":{"n":"btreesetvaluetree"}}],[11,"fmt","","",25,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",24,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",25,null],[11,"simplify","","",25,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",25,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",26,{"i":[{"n":"self"}],"o":{"n":"hashmapstrategy"}}],[11,"fmt","","",26,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",27,{"i":[{"n":"self"}],"o":{"n":"hashmapvaluetree"}}],[11,"fmt","","",27,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",26,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",27,null],[11,"simplify","","",27,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",27,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",28,{"i":[{"n":"self"}],"o":{"n":"btreemapstrategy"}}],[11,"fmt","","",28,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",29,{"i":[{"n":"self"}],"o":{"n":"btreemapvaluetree"}}],[11,"fmt","","",29,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",28,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",29,null],[11,"simplify","","",29,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",29,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",30,{"i":[{"n":"self"}],"o":{"n":"vecvaluetree"}}],[11,"fmt","","",30,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",15,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",30,{"i":[{"n":"self"}],"o":{"n":"vec"}}],[11,"simplify","","",30,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",30,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"num","proptest","Strategies to generate numeric values (as opposed to integers used as bit fields).",null,null],[0,"i8","proptest::num","",null,null],[3,"Any","proptest::num::i8","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",31,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",31,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",31,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",32,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",32,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",32,{"i":[{"n":"i8"}],"o":{"n":"self"}}],[11,"current","","",32,{"i":[{"n":"self"}],"o":{"n":"i8"}}],[11,"simplify","","",32,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",32,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"i16","proptest::num","",null,null],[3,"Any","proptest::num::i16","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",33,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",33,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",33,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",34,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",34,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",34,{"i":[{"n":"i16"}],"o":{"n":"self"}}],[11,"current","","",34,{"i":[{"n":"self"}],"o":{"n":"i16"}}],[11,"simplify","","",34,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",34,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"i32","proptest::num","",null,null],[3,"Any","proptest::num::i32","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",35,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",35,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",35,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",36,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",36,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",36,{"i":[{"n":"i32"}],"o":{"n":"self"}}],[11,"current","","",36,{"i":[{"n":"self"}],"o":{"n":"i32"}}],[11,"simplify","","",36,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",36,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"i64","proptest::num","",null,null],[3,"Any","proptest::num::i64","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",37,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",37,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",37,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",38,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",38,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",38,{"i":[{"n":"i64"}],"o":{"n":"self"}}],[11,"current","","",38,{"i":[{"n":"self"}],"o":{"n":"i64"}}],[11,"simplify","","",38,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",38,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"i128","proptest::num","",null,null],[3,"Any","proptest::num::i128","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",39,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",39,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",39,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",40,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",40,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",40,{"i":[{"n":"i128"}],"o":{"n":"self"}}],[11,"current","","",40,{"i":[{"n":"self"}],"o":{"n":"i128"}}],[11,"simplify","","",40,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",40,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"isize","proptest::num","",null,null],[3,"Any","proptest::num::isize","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",41,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",41,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",41,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",42,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",42,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",42,{"i":[{"n":"isize"}],"o":{"n":"self"}}],[11,"current","","",42,{"i":[{"n":"self"}],"o":{"n":"isize"}}],[11,"simplify","","",42,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",42,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"u8","proptest::num","",null,null],[3,"Any","proptest::num::u8","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",43,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",43,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",43,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",44,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",44,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",44,{"i":[{"n":"u8"}],"o":{"n":"self"}}],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",44,{"i":[{"n":"u8"},{"n":"u8"}],"o":{"n":"self"}}],[11,"current","","",44,{"i":[{"n":"self"}],"o":{"n":"u8"}}],[11,"simplify","","",44,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",44,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"u16","proptest::num","",null,null],[3,"Any","proptest::num::u16","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",45,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",45,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",45,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",46,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",46,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",46,{"i":[{"n":"u16"}],"o":{"n":"self"}}],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",46,{"i":[{"n":"u16"},{"n":"u16"}],"o":{"n":"self"}}],[11,"current","","",46,{"i":[{"n":"self"}],"o":{"n":"u16"}}],[11,"simplify","","",46,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",46,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"u32","proptest::num","",null,null],[3,"Any","proptest::num::u32","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",47,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",47,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",47,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",48,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",48,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",48,{"i":[{"n":"u32"}],"o":{"n":"self"}}],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",48,{"i":[{"n":"u32"},{"n":"u32"}],"o":{"n":"self"}}],[11,"current","","",48,{"i":[{"n":"self"}],"o":{"n":"u32"}}],[11,"simplify","","",48,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",48,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"u64","proptest::num","",null,null],[3,"Any","proptest::num::u64","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",49,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",49,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",49,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",50,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",50,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",50,{"i":[{"n":"u64"}],"o":{"n":"self"}}],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",50,{"i":[{"n":"u64"},{"n":"u64"}],"o":{"n":"self"}}],[11,"current","","",50,{"i":[{"n":"self"}],"o":{"n":"u64"}}],[11,"simplify","","",50,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",50,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"u128","proptest::num","",null,null],[3,"Any","proptest::num::u128","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",51,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",51,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",51,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",52,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",52,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",52,{"i":[{"n":"u128"}],"o":{"n":"self"}}],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",52,{"i":[{"n":"u128"},{"n":"u128"}],"o":{"n":"self"}}],[11,"current","","",52,{"i":[{"n":"self"}],"o":{"n":"u128"}}],[11,"simplify","","",52,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",52,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"usize","proptest::num","",null,null],[3,"Any","proptest::num::usize","Type of the `ANY` constant.",null,null],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",null,null],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",null,null],[11,"clone","","",53,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",53,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",53,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",54,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",54,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",54,{"i":[{"n":"usize"}],"o":{"n":"self"}}],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",54,{"i":[{"n":"usize"},{"n":"usize"}],"o":{"n":"self"}}],[11,"current","","",54,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[11,"simplify","","",54,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",54,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"f32","proptest::num","",null,null],[3,"Any","proptest::num::f32","Strategies which produce floating-point values from particular classes. See the various `Any`-typed constants in this module.",null,null],[3,"BinarySearch","","Shrinks a float towards 0, using binary search to find boundary points.",null,null],[17,"POSITIVE","","Generates positive floats",null,null],[17,"NEGATIVE","","Generates negative floats.",null,null],[17,"NORMAL","","Generates \"normal\" floats.",null,null],[17,"SUBNORMAL","","Generates subnormal floats.",null,null],[17,"ZERO","","Generates zero-valued floats.",null,null],[17,"INFINITE","","Generates infinity floats.",null,null],[17,"QUIET_NAN","","Generates \"Quiet NaN\" floats.",null,null],[17,"SIGNALING_NAN","","Generates \"Signaling NaN\" floats if allowed by the platform.",null,null],[17,"ANY","","Generates literally arbitrary floating-point values, including infinities and quiet NaNs (but not signaling NaNs).",null,null],[11,"clone","","",55,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",55,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"bitor","","",55,{"i":[{"n":"self"},{"n":"self"}],"o":{"n":"self"}}],[11,"bitor_assign","","",55,{"i":[{"n":"self"},{"n":"self"}]}],[11,"new_tree","","",55,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",56,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",56,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",56,{"i":[{"n":"f32"}],"o":{"n":"self"}}],[11,"current","","",56,{"i":[{"n":"self"}],"o":{"n":"f32"}}],[11,"simplify","","",56,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",56,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"f64","proptest::num","",null,null],[3,"Any","proptest::num::f64","Strategies which produce floating-point values from particular classes. See the various `Any`-typed constants in this module.",null,null],[3,"BinarySearch","","Shrinks a float towards 0, using binary search to find boundary points.",null,null],[17,"POSITIVE","","Generates positive floats",null,null],[17,"NEGATIVE","","Generates negative floats.",null,null],[17,"NORMAL","","Generates \"normal\" floats.",null,null],[17,"SUBNORMAL","","Generates subnormal floats.",null,null],[17,"ZERO","","Generates zero-valued floats.",null,null],[17,"INFINITE","","Generates infinity floats.",null,null],[17,"QUIET_NAN","","Generates \"Quiet NaN\" floats.",null,null],[17,"SIGNALING_NAN","","Generates \"Signaling NaN\" floats if allowed by the platform.",null,null],[17,"ANY","","Generates literally arbitrary floating-point values, including infinities and quiet NaNs (but not signaling NaNs).",null,null],[11,"clone","","",57,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"fmt","","",57,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"bitor","","",57,{"i":[{"n":"self"},{"n":"self"}],"o":{"n":"self"}}],[11,"bitor_assign","","",57,{"i":[{"n":"self"},{"n":"self"}]}],[11,"new_tree","","",57,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",58,{"i":[{"n":"self"}],"o":{"n":"binarysearch"}}],[11,"fmt","","",58,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Creates a new binary searcher starting at the given value.",58,{"i":[{"n":"f64"}],"o":{"n":"self"}}],[11,"current","","",58,{"i":[{"n":"self"}],"o":{"n":"f64"}}],[11,"simplify","","",58,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",58,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"strategy","proptest","Defines the core traits used by Proptest.",null,null],[3,"NoShrink","proptest::strategy","Wraps a `Strategy` or `ValueTree` to suppress shrinking of generated values.",null,null],[3,"BoxedStrategy","","A boxed `Strategy` trait object as produced by `Strategy::boxed()`.",null,null],[3,"SBoxedStrategy","","A boxed `Strategy` trait object which is also `Sync` and `Send`, as produced by `Strategy::sboxed()`.",null,null],[3,"CheckStrategySanityOptions","","Options passed to `check_strategy_sanity()`.",null,null],[12,"strict_complicate_after_simplify","","If true (the default), require that `complicate()` return `true` at least once after any call to `simplify()` which itself returns once.",59,null],[3,"Just","","A `Strategy` which always produces a single value value and never simplifies.",null,null],[12,"0","","The value produced by this strategy.",60,null],[3,"LazyJust","","A `Strategy` which always produces a single value value and never simplifies. If `T` is `Clone`, you should use `Just` instead.",null,null],[3,"Map","","`Strategy` and `ValueTree` map adaptor.",null,null],[3,"MapInto","","`Strategy` and `ValueTree` map into adaptor.",null,null],[3,"Perturb","","`Strategy` perturbation adaptor.",null,null],[3,"PerturbValueTree","","`ValueTree` perturbation adaptor.",null,null],[3,"Filter","","`Strategy` and `ValueTree` filter adaptor.",null,null],[3,"FilterMap","","`Strategy` and `ValueTree` filter_map adaptor.",null,null],[3,"FilterMapValueTree","","`ValueTree` corresponding to `FilterMap`.",null,null],[3,"Flatten","","Adaptor that flattens a `Strategy` which produces other `Strategy`s into a `Strategy` that picks one of those strategies and then picks values from it.",null,null],[3,"FlattenValueTree","","The `ValueTree` produced by `Flatten`.",null,null],[3,"IndFlatten","","Similar to `Flatten`, but does not shrink the input strategy.",null,null],[3,"IndFlattenMap","","Similar to `Map` plus `Flatten`, but does not shrink the input strategy and passes the original input through.",null,null],[3,"Union","","A `Strategy` which picks from one of several delegate `Stragegy`s.",null,null],[3,"UnionValueTree","","`ValueTree` corresponding to `Union`.",null,null],[3,"TupleUnion","","Similar to `Union`, but internally uses a tuple to hold the strategies.",null,null],[3,"TupleUnionValueTree","","`ValueTree` type produced by `TupleUnion`.",null,null],[3,"Recursive","","Return type from `Strategy::prop_recursive()`.",null,null],[3,"Shuffle","","`Strategy` shuffle adaptor.",null,null],[3,"ShuffleValueTree","","`ValueTree` shuffling adaptor.",null,null],[3,"Fuse","","Adaptor for `Strategy` and `ValueTree` which guards `simplify()` and `complicate()` to avoid contract violations.",null,null],[5,"check_strategy_sanity","","Run some tests on the given `Strategy` to ensure that it upholds the simplify/complicate contracts.",null,{"i":[{"n":"s"},{"g":["checkstrategysanityoptions"],"n":"option"}]}],[5,"float_to_weight","","Convert a floating-point weight in the range (0.0,1.0) to a pair of weights that can be used with `Union` and similar.",null,null],[11,"clone","","",61,{"i":[{"n":"self"}],"o":{"n":"noshrink"}}],[11,"fmt","","",61,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",61,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",61,null],[11,"simplify","","",61,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",61,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",62,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",63,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",62,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"clone","","",63,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"new_tree","","",62,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"boxed","","",62,{"i":[{"n":"self"}],"o":{"n":"boxedstrategy"}}],[11,"new_tree","","",63,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"sboxed","","",63,{"i":[{"n":"self"}],"o":{"n":"sboxedstrategy"}}],[11,"boxed","","",63,{"i":[{"n":"self"}],"o":{"n":"boxedstrategy"}}],[11,"clone","","",59,{"i":[{"n":"self"}],"o":{"n":"checkstrategysanityoptions"}}],[11,"fmt","","",59,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"default","","",59,{"o":{"n":"self"}}],[11,"clone","","",60,{"i":[{"n":"self"}],"o":{"n":"just"}}],[11,"fmt","","",60,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",60,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"simplify","","",60,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",60,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",60,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"new","","Constructs a `LazyJust` strategy given the function/closure that produces the value.",64,{"i":[{"n":"f"}],"o":{"n":"self"}}],[11,"new_tree","","",64,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"simplify","","",64,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",64,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",64,null],[11,"clone","","",64,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"fmt","","",64,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",65,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",65,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"new_tree","","",65,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",65,{"i":[{"n":"self"}],"o":{"n":"o"}}],[11,"simplify","","",65,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",65,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",66,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",66,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"new_tree","","",66,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",66,{"i":[{"n":"self"}],"o":{"n":"o"}}],[11,"simplify","","",66,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",66,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",67,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",67,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"new_tree","","",67,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"fmt","","",68,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",68,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"current","","",68,{"i":[{"n":"self"}],"o":{"n":"o"}}],[11,"simplify","","",68,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",68,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",69,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",69,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"new_tree","","",69,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",69,null],[11,"simplify","","",69,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",69,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",70,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",70,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"new_tree","","",70,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",71,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"fmt","","",71,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"current","","",71,{"i":[{"n":"self"}],"o":{"n":"o"}}],[11,"simplify","","",71,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",71,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",72,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",72,{"i":[{"n":"self"}],"o":{"n":"flatten"}}],[11,"new","","Wrap `source` to flatten it.",72,{"i":[{"n":"s"}],"o":{"n":"self"}}],[11,"new_tree","","",72,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",73,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"fmt","","",73,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"current","","",73,null],[11,"simplify","","",73,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",73,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",74,{"i":[{"n":"self"}],"o":{"n":"indflatten"}}],[11,"fmt","","",74,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",74,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"fmt","","",75,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",75,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"new_tree","","",75,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",76,{"i":[{"n":"self"}],"o":{"n":"union"}}],[11,"fmt","","",76,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Create a strategy which selects uniformly from the given delegate strategies.",76,null],[11,"new_weighted","","Create a strategy which selects from the given delegate strategies.",76,{"i":[{"g":["w"],"n":"vec"}],"o":{"n":"self"}}],[11,"or","","Add `other` as an additional alternate strategy with weight 1.",76,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"self"}}],[11,"new_tree","","",76,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",77,{"i":[{"n":"self"}],"o":{"n":"unionvaluetree"}}],[11,"fmt","","",77,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"current","","",77,null],[11,"simplify","","",77,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",77,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",78,{"i":[{"n":"self"}],"o":{"n":"tupleunion"}}],[11,"fmt","","",78,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Wrap `tuple` in a `TupleUnion`.",78,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"new_tree","","",78,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"new_tree","","",78,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"new_tree","","",78,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"new_tree","","",78,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"new_tree","","",78,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"new_tree","","",78,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"new_tree","","",78,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"new_tree","","",78,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"new_tree","","",78,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",79,{"i":[{"n":"self"}],"o":{"n":"tupleunionvaluetree"}}],[11,"fmt","","",79,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"current","","",79,null],[11,"simplify","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",79,null],[11,"simplify","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",79,null],[11,"simplify","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",79,null],[11,"simplify","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",79,null],[11,"simplify","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",79,null],[11,"simplify","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",79,null],[11,"simplify","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",79,null],[11,"simplify","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",79,null],[11,"simplify","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",79,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",80,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",80,{"i":[{"n":"self"}],"o":{"n":"self"}}],[11,"new_tree","","",80,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",81,{"i":[{"n":"self"}],"o":{"n":"shuffle"}}],[11,"fmt","","",81,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",81,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"clone","","",82,{"i":[{"n":"self"}],"o":{"n":"shufflevaluetree"}}],[11,"fmt","","",82,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"current","","",82,null],[11,"simplify","","",82,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",82,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",83,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",83,{"i":[{"n":"self"}],"o":{"n":"fuse"}}],[11,"new","","Wrap the given `T` in `Fuse`.",83,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"new_tree","","",83,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"may_simplify","","Return whether a call to `simplify()` may be productive.",83,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"disallow_simplify","","Disallow any further calls to `simplify()` until a call to `complicate()` returns `true`.",83,{"i":[{"n":"self"}]}],[11,"may_complicate","","Return whether a call to `complicate()` may be productive.",83,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"disallow_complicate","","Disallow any further calls to `complicate()` until a call to `simplify()` returns `true`.",83,{"i":[{"n":"self"}]}],[11,"freeze","","Prevent any further shrinking operations from occurring.",83,{"i":[{"n":"self"}]}],[11,"current","","",83,null],[11,"simplify","","",83,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",83,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"statics","","Modified versions of the normal strategy combinators which take specialised traits instead of normal functions.",null,null],[3,"Filter","proptest::strategy::statics","Static version of `strategy::Filter`.",null,null],[3,"Map","","Static version of `strategy::Map`.",null,null],[8,"FilterFn","","Essentially `Fn (&T) -> bool`.",null,null],[10,"apply","","Test whether `t` passes the filter.",84,{"i":[{"n":"self"},{"n":"t"}],"o":{"n":"bool"}}],[8,"MapFn","","Essentially `Fn (T) -> Output`.",null,null],[16,"Output","","",85,null],[10,"apply","","Map `T` to `Output`.",85,null],[11,"clone","","",86,{"i":[{"n":"self"}],"o":{"n":"filter"}}],[11,"new","","Adapt strategy `source` to reject values which do not pass `filter`, using `whence` as the reported reason/location.",86,{"i":[{"n":"s"},{"n":"reason"},{"n":"f"}],"o":{"n":"self"}}],[11,"fmt","","",86,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",86,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",86,null],[11,"simplify","","",86,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",86,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",87,{"i":[{"n":"self"}],"o":{"n":"map"}}],[11,"new","","Adapt strategy `source` by applying `fun` to values it produces.",87,{"i":[{"n":"s"},{"n":"f"}],"o":{"n":"self"}}],[11,"fmt","","",87,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",87,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",87,null],[11,"simplify","","",87,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",87,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[6,"NewTree","proptest::strategy","A new [`ValueTree`] from a [`Strategy`] when [`Ok`] or otherwise [`Err`] when a new value-tree can not be produced for some reason such as in the case of filtering with a predicate which always returns false. You should pass in your strategy as the type parameter.",null,null],[6,"ValueFor","","The value that functions under test use for a particular `Strategy`.",null,null],[6,"LazyJustFn","","Shorthand for `LazyJust<T, fn () -> T>`.",null,null],[6,"W","","A relative `weight` of a particular `Strategy` corresponding to `T` coupled with `T` itself. The weight is currently given in `u32`.",null,null],[8,"Strategy","","A strategy for producing arbitrary values of a given type.",null,null],[16,"Tree","","The value tree generated by this `Strategy`.",88,null],[16,"Value","","The type of value used by functions under test generated by this Strategy.",88,null],[10,"new_tree","","Generate a new value tree from the given runner.",88,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"prop_map","","Returns a strategy which produces values transformed by the function `fun`.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"map"}}],[11,"prop_map_into","","Returns a strategy which produces values of type `O` by transforming `Self` with `Into<O>`.",88,{"i":[{"n":"self"}],"o":{"n":"mapinto"}}],[11,"prop_perturb","","Returns a strategy which produces values transformed by the function `fun`, which is additionally given a random number generator.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"perturb"}}],[11,"prop_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["map"],"n":"flatten"}}],[11,"prop_ind_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies while considering the new strategies to be independent.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["map"],"n":"indflatten"}}],[11,"prop_ind_flat_map2","","Similar to `prop_ind_flat_map()`, but produces 2-tuples with the input generated from `self` in slot 0 and the derived strategy in slot 1.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"indflattenmap"}}],[11,"prop_filter","","Returns a strategy which only produces values accepted by `fun`.",88,{"i":[{"n":"self"},{"n":"r"},{"n":"f"}],"o":{"n":"filter"}}],[11,"prop_filter_map","","Returns a strategy which only produces transformed values where `fun` returns `Some(value)` and rejects those where `fun` returns `None`.",88,null],[11,"prop_union","","Returns a strategy which picks uniformly from `self` and `other`.",88,{"i":[{"n":"self"},{"n":"self"}],"o":{"n":"union"}}],[11,"prop_recursive","","Generate a recursive structure with `self` items as leaves.",88,{"i":[{"n":"self"},{"n":"u32"},{"n":"u32"},{"n":"u32"},{"n":"f"}],"o":{"n":"recursive"}}],[11,"prop_shuffle","","Shuffle the contents of the values produced by this strategy.",88,{"i":[{"n":"self"}],"o":{"n":"shuffle"}}],[11,"boxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,{"i":[{"n":"self"}],"o":{"n":"boxedstrategy"}}],[11,"sboxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,{"i":[{"n":"self"}],"o":{"n":"sboxedstrategy"}}],[11,"no_shrink","","Wraps this strategy to prevent values from being subject to shrinking.",88,{"i":[{"n":"self"}],"o":{"n":"noshrink"}}],[8,"ValueTree","","A generated value and its associated shrinker.",null,null],[16,"Value","","The type of the value produced by this `ValueTree`.",89,null],[10,"current","","Returns the current value.",89,null],[10,"simplify","","Attempts to simplify the current value. Notionally, this sets the \"high\" value to the current value, and the current value to a \"halfway point\" between high and low, rounding towards low.",89,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[10,"complicate","","Attempts to partially undo the last simplification. Notionally, this sets the \"low\" value to one plus the current value, and the current value to a \"halfway point\" between high and the new low, rounding towards low.",89,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[8,"Shuffleable","","A value which can be used with the `prop_shuffle` combinator.",null,null],[10,"shuffle_len","","Return the length of this collection.",90,{"i":[{"n":"self"}],"o":{"n":"usize"}}],[10,"shuffle_swap","","Swap the elements at the given indices.",90,{"i":[{"n":"self"},{"n":"usize"},{"n":"usize"}]}],[0,"test_runner","proptest","State and functions for running proptest tests.",null,null],[3,"TestRng","proptest::test_runner","Proptest's random number generator.",null,null],[3,"MapFailurePersistence","","Failure persistence option that loads and saves seeds in memory on the heap. This may be useful when accumulating test failures across multiple `TestRunner` instances for external reporting or batched persistence.",null,null],[12,"map","","Backing map, keyed by source_file.",91,null],[3,"Config","","Configuration for how a proptest test should be run.",null,null],[12,"cases","","The number of successful test cases that must execute for the test as a whole to pass.",92,null],[12,"max_local_rejects","","The maximum number of individual inputs that may be rejected before the test as a whole aborts.",92,null],[12,"max_global_rejects","","The maximum number of combined inputs that may be rejected before the test as a whole aborts.",92,null],[12,"max_flat_map_regens","","The maximum number of times all `Flatten` combinators will attempt to regenerate values. This puts a limit on the worst-case exponential explosion that can happen with nested `Flatten`s.",92,null],[12,"failure_persistence","","Indicates whether and how to persist failed test results.",92,null],[12,"source_file","","File location of the current test, relevant for persistence and debugging.",92,null],[12,"test_name","","The fully-qualified name of the test being run, as would be passed to the test executable to run just that test.",92,null],[12,"fork","","If true, tests are run in a subprocess.",92,null],[12,"timeout","","If non-zero, tests are run in a subprocess and each generated case fails if it takes longer than this number of milliseconds.",92,null],[3,"Reason","","The reason for why something, such as a generated value, was rejected.",null,null],[3,"TestRunner","","State used when running a proptest test.",null,null],[4,"FileFailurePersistence","","Describes how failing test cases are persisted.",null,null],[13,"Off","","Completely disables persistence of failing test cases.",93,null],[13,"SourceParallel","","The path given to `TestRunner::set_source_file()` is parsed. The path is traversed up the directory tree until a directory containing a file named `lib.rs` or `main.rs` is found. A sibling to that directory with the name given by the string in this configuration is created, and a file with the same name and path relative to the source directory, but with the extension changed to `.txt`, is used.",93,null],[13,"WithSource","","The path given to `TestRunner::set_source_file()` is parsed. The extension of the path is changed to the string given in this configuration, and that filename is used.",93,null],[13,"Direct","","The string given in this option is directly used as a file path without any further processing.",93,null],[4,"TestCaseError","","Errors which can be returned from test cases to indicate non-successful completion.",null,null],[13,"Reject","","The input was not valid for the test case. This does not count as a test failure (nor a success); rather, it simply signals to generate a new input and try again.",94,null],[13,"Fail","","The code under test failed the test.",94,null],[4,"TestError","","A failure state from running test cases for a single test.",null,null],[13,"Abort","","The test was aborted for the given reason, for example, due to too many inputs having been rejected.",95,null],[13,"Fail","","A failing test case was found. The string indicates where and/or why the test failed. The `T` is the minimal input found to reproduce the failure.",95,null],[11,"clone","","",96,{"i":[{"n":"self"}],"o":{"n":"testrng"}}],[11,"fmt","","",96,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"next_u32","","",96,{"i":[{"n":"self"}],"o":{"n":"u32"}}],[11,"next_u64","","",96,{"i":[{"n":"self"}],"o":{"n":"u64"}}],[11,"fill_bytes","","",96,null],[11,"try_fill_bytes","","",96,null],[11,"clone","","",93,{"i":[{"n":"self"}],"o":{"n":"filefailurepersistence"}}],[11,"fmt","","",93,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",93,{"i":[{"n":"self"},{"n":"filefailurepersistence"}],"o":{"n":"bool"}}],[11,"ne","","",93,{"i":[{"n":"self"},{"n":"filefailurepersistence"}],"o":{"n":"bool"}}],[11,"default","","",93,{"o":{"n":"self"}}],[11,"load_persisted_failures","","",93,{"i":[{"n":"self"},{"g":["str"],"n":"option"}],"o":{"n":"vec"}}],[11,"save_persisted_failure","","",93,null],[11,"box_clone","","",93,{"i":[{"n":"self"}],"o":{"g":["failurepersistence"],"n":"box"}}],[11,"eq","","",93,{"i":[{"n":"self"},{"n":"failurepersistence"}],"o":{"n":"bool"}}],[11,"as_any","","",93,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"clone","","",91,{"i":[{"n":"self"}],"o":{"n":"mapfailurepersistence"}}],[11,"fmt","","",91,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"default","","",91,{"o":{"n":"mapfailurepersistence"}}],[11,"eq","","",91,{"i":[{"n":"self"},{"n":"mapfailurepersistence"}],"o":{"n":"bool"}}],[11,"ne","","",91,{"i":[{"n":"self"},{"n":"mapfailurepersistence"}],"o":{"n":"bool"}}],[11,"load_persisted_failures","","",91,{"i":[{"n":"self"},{"g":["str"],"n":"option"}],"o":{"n":"vec"}}],[11,"save_persisted_failure","","",91,null],[11,"box_clone","","",91,{"i":[{"n":"self"}],"o":{"g":["failurepersistence"],"n":"box"}}],[11,"eq","","",91,{"i":[{"n":"self"},{"n":"failurepersistence"}],"o":{"n":"bool"}}],[11,"as_any","","",91,{"i":[{"n":"self"}],"o":{"n":"any"}}],[11,"clone","","",92,{"i":[{"n":"self"}],"o":{"n":"config"}}],[11,"fmt","","",92,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"eq","","",92,{"i":[{"n":"self"},{"n":"config"}],"o":{"n":"bool"}}],[11,"ne","","",92,{"i":[{"n":"self"},{"n":"config"}],"o":{"n":"bool"}}],[11,"with_cases","","Constructs a `Config` only differing from the `default()` in the number of test cases required to pass the test successfully.",92,{"i":[{"n":"u32"}],"o":{"n":"self"}}],[11,"with_source_file","","Constructs a `Config` only differing from the `default()` in the source_file of the present test.",92,{"i":[{"n":"str"}],"o":{"n":"self"}}],[11,"clone_with_source_file","","Constructs a `Config` only differing from the provided Config instance, `self`, in the source_file of the present test.",92,{"i":[{"n":"self"},{"n":"str"}],"o":{"n":"self"}}],[11,"fork","","Return whether this configuration implies forking.",92,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"timeout","","Returns the configured timeout.",92,{"i":[{"n":"self"}],"o":{"n":"u32"}}],[11,"default","","",92,{"o":{"n":"self"}}],[11,"fmt","","",97,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",97,{"i":[{"n":"self"}],"o":{"n":"reason"}}],[11,"eq","","",97,{"i":[{"n":"self"},{"n":"reason"}],"o":{"n":"bool"}}],[11,"ne","","",97,{"i":[{"n":"self"},{"n":"reason"}],"o":{"n":"bool"}}],[11,"partial_cmp","","",97,{"i":[{"n":"self"},{"n":"reason"}],"o":{"g":["ordering"],"n":"option"}}],[11,"lt","","",97,{"i":[{"n":"self"},{"n":"reason"}],"o":{"n":"bool"}}],[11,"le","","",97,{"i":[{"n":"self"},{"n":"reason"}],"o":{"n":"bool"}}],[11,"gt","","",97,{"i":[{"n":"self"},{"n":"reason"}],"o":{"n":"bool"}}],[11,"ge","","",97,{"i":[{"n":"self"},{"n":"reason"}],"o":{"n":"bool"}}],[11,"cmp","","",97,{"i":[{"n":"self"},{"n":"reason"}],"o":{"n":"ordering"}}],[11,"hash","","",97,null],[11,"message","","Return the message for this `Reason`.",97,{"i":[{"n":"self"}],"o":{"n":"str"}}],[11,"from","","",97,{"i":[{"n":"str"}],"o":{"n":"self"}}],[11,"from","","",97,{"i":[{"n":"string"}],"o":{"n":"self"}}],[11,"from","","",97,{"i":[{"g":["str"],"n":"box"}],"o":{"n":"self"}}],[11,"fmt","","",97,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",94,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",94,{"i":[{"n":"self"}],"o":{"n":"testcaseerror"}}],[11,"reject","","Rejects the generated test input as invalid for this test case. This does not count as a test failure (nor a success); rather, it simply signals to generate a new input and try again.",94,null],[11,"fail","","The code under test failed the test.",94,null],[11,"fmt","","",94,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"from","","",94,{"i":[{"n":"e"}],"o":{"n":"self"}}],[11,"fmt","","",95,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",95,{"i":[{"n":"self"}],"o":{"n":"testerror"}}],[11,"eq","","",95,{"i":[{"n":"self"},{"n":"testerror"}],"o":{"n":"bool"}}],[11,"ne","","",95,{"i":[{"n":"self"},{"n":"testerror"}],"o":{"n":"bool"}}],[11,"fmt","","",95,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"description","","",95,{"i":[{"n":"self"}],"o":{"n":"str"}}],[11,"clone","","",98,{"i":[{"n":"self"}],"o":{"n":"testrunner"}}],[11,"fmt","","",98,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",98,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"default","","",98,{"o":{"n":"self"}}],[11,"new","","Create a fresh `TestRunner` with the given configuration.",98,{"i":[{"n":"config"}],"o":{"n":"self"}}],[11,"rng","","Returns the RNG for this test run.",98,{"i":[{"n":"self"}],"o":{"n":"testrng"}}],[11,"new_rng","","Create a new, independent but deterministic RNG from the RNG in this runner.",98,{"i":[{"n":"self"}],"o":{"n":"testrng"}}],[11,"config","","Returns the configuration of this runner.",98,{"i":[{"n":"self"}],"o":{"n":"config"}}],[11,"run","","Run test cases against `f`, choosing inputs via `strategy`.",98,null],[11,"run_one","","Run one specific test case against this runner.",98,null],[11,"reject_local","","Update the state to account for a local rejection from `whence`, and return `Ok` if the caller should keep going or `Err` to abort.",98,null],[11,"flat_map_regen","","Increment the counter of flat map regenerations and return whether it is still under the configured limit.",98,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[6,"TestCaseResult","","Convenience for the type returned by test cases.",null,null],[8,"FailurePersistence","","Provides external persistence for historical test failures by storing seeds.",null,null],[10,"load_persisted_failures","","Supply seeds associated with the given `source_file` that may be used by a `TestRunner`'s random number generator in order to consistently recreate a previously-failing `Strategy`-provided value.",99,{"i":[{"n":"self"},{"g":["str"],"n":"option"}],"o":{"n":"vec"}}],[10,"save_persisted_failure","","Store a new failure-generating seed associated with the given `source_file`.",99,null],[10,"box_clone","","Delegate method for producing a trait object usable with `Clone`",99,{"i":[{"n":"self"}],"o":{"g":["failurepersistence"],"n":"box"}}],[10,"eq","","Equality testing delegate required due to constraints of trait objects.",99,{"i":[{"n":"self"},{"n":"failurepersistence"}],"o":{"n":"bool"}}],[10,"as_any","","Assistant method for trait object comparison.",99,{"i":[{"n":"self"}],"o":{"n":"any"}}],[0,"tuple","proptest","Support for combining strategies into tuples.",null,null],[3,"TupleValueTree","proptest::tuple","Common `ValueTree` implementation for all tuple strategies.",null,null],[11,"clone","","",100,{"i":[{"n":"self"}],"o":{"n":"tuplevaluetree"}}],[11,"fmt","","",100,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new","","Create a new `TupleValueTree` wrapping `inner`.",100,{"i":[{"n":"t"}],"o":{"n":"self"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"current","","",100,null],[11,"simplify","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",100,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"option","proptest","Strategies for generating `std::Option` values.",null,null],[3,"Probability","proptest::option","A probability in the range `[0.0, 1.0]` with a default of `0.5`.",null,null],[3,"OptionStrategy","","Strategy which generates `Option` values whose inner `Some` values are generated by another strategy.",null,null],[3,"OptionValueTree","","`ValueTree` type corresponding to `OptionStrategy`.",null,null],[5,"prob","","Creates a `Probability` from some value that is convertible into it.",null,null],[5,"of","","Return a strategy producing `Optional` values wrapping values from the given delegate strategy.",null,{"i":[{"n":"t"}],"o":{"n":"optionstrategy"}}],[5,"weighted","","Return a strategy producing `Optional` values wrapping values from the given delegate strategy.",null,null],[11,"default","","The default probability is 0.5, or 50% chance.",101,{"o":{"n":"self"}}],[11,"from","","Creates a `Probability` from a `f64`.",101,{"i":[{"n":"f64"}],"o":{"n":"self"}}],[11,"new","","Creates a `Probability` from a `f64`.",101,{"i":[{"n":"f64"}],"o":{"n":"self"}}],[11,"with","","Merges self together with some other argument producing a product type expected by some impelementations of `A: Arbitrary` in `A::Parameters`. This can be more ergonomic to work with and may help type inference.",101,null],[11,"lift","","Merges self together with some other argument generated with a default value producing a product type expected by some impelementations of `A: Arbitrary` in `A::Parameters`. This can be more ergonomic to work with and may help type inference.",101,null],[11,"clone","","",101,{"i":[{"n":"self"}],"o":{"n":"probability"}}],[11,"eq","","",101,{"i":[{"n":"self"},{"n":"probability"}],"o":{"n":"bool"}}],[11,"ne","","",101,{"i":[{"n":"self"},{"n":"probability"}],"o":{"n":"bool"}}],[11,"fmt","","",101,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",102,{"i":[{"n":"self"}],"o":{"n":"optionstrategy"}}],[11,"clone","","",103,{"i":[{"n":"self"}],"o":{"n":"optionvaluetree"}}],[11,"fmt","","",103,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",102,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",103,null],[11,"simplify","","",103,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",103,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",102,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[0,"result","proptest","Strategies for combining delegate strategies into `std::Result`s.",null,null],[3,"MaybeOk","proptest::result","Strategy which generates `Result`s using `Ok` and `Err` values from two delegate strategies.",null,null],[3,"MaybeOkValueTree","","`ValueTree` type corresponding to `MaybeOk`.",null,null],[3,"MaybeErr","","Strategy which generates `Result`s using `Ok` and `Err` values from two delegate strategies.",null,null],[3,"MaybeErrValueTree","","`ValueTree` type corresponding to `MaybeErr`.",null,null],[5,"maybe_ok","","Create a strategy for `Result`s where `Ok` values are taken from `t` and `Err` values are taken from `e`.",null,{"i":[{"n":"t"},{"n":"e"}],"o":{"n":"maybeok"}}],[5,"maybe_ok_weighted","","Create a strategy for `Result`s where `Ok` values are taken from `t` and `Err` values are taken from `e`.",null,null],[5,"maybe_err","","Create a strategy for `Result`s where `Ok` values are taken from `t` and `Err` values are taken from `e`.",null,{"i":[{"n":"t"},{"n":"e"}],"o":{"n":"maybeerr"}}],[5,"maybe_err_weighted","","Create a strategy for `Result`s where `Ok` values are taken from `t` and `Err` values are taken from `e`.",null,null],[11,"clone","","",104,{"i":[{"n":"self"}],"o":{"n":"maybeok"}}],[11,"clone","","",105,{"i":[{"n":"self"}],"o":{"n":"maybeokvaluetree"}}],[11,"fmt","","",105,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",104,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",105,null],[11,"simplify","","",105,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",105,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",106,{"i":[{"n":"self"}],"o":{"n":"maybeerr"}}],[11,"clone","","",107,{"i":[{"n":"self"}],"o":{"n":"maybeerrvaluetree"}}],[11,"fmt","","",107,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",106,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",107,null],[11,"simplify","","",107,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",107,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"fmt","","",104,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",106,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[0,"sample","proptest","Strategies for generating values by taking samples of collections.",null,null],[3,"Subsequence","proptest::sample","Strategy to generate `Vec`s by sampling a subsequence from another collection.",null,null],[3,"SubsequenceValueTree","","`ValueTree` type for `Subsequence`.",null,null],[3,"Select","","Strategy to produce one value from a fixed collection of options.",null,null],[3,"SelectValueTree","","`ValueTree` corresponding to `Select`.",null,null],[5,"subsequence","","Sample subsequences whose size are within `size` from the given collection `values`.",null,null],[5,"select","","Create a strategy which uniformly selects one value from `values`.",null,null],[11,"fmt","","",108,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",108,{"i":[{"n":"self"}],"o":{"n":"subsequence"}}],[11,"new_tree","","",108,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"fmt","","",109,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",109,{"i":[{"n":"self"}],"o":{"n":"subsequencevaluetree"}}],[11,"current","","",109,null],[11,"simplify","","",109,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",109,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"clone","","",110,{"i":[{"n":"self"}],"o":{"n":"select"}}],[11,"fmt","","",110,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"clone","","",111,{"i":[{"n":"self"}],"o":{"n":"selectvaluetree"}}],[11,"fmt","","",111,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",110,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",111,null],[11,"simplify","","",111,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",111,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"string","proptest","Strategies for generating strings and byte strings from regular expressions.",null,null],[3,"StringParam","proptest::string","Wraps the regex that forms the `Strategy` for `String` so that a sensible `Default` can be given. The default is a string of non-control characters.",null,null],[3,"RegexGeneratorStrategy","","Strategy which generates values (i.e., `String` or `Vec<u8>`) matching a regular expression.",null,null],[3,"RegexGeneratorValueTree","","`ValueTree` corresponding to `RegexGeneratorStrategy`.",null,null],[4,"Error","","Errors which may occur when preparing a regular expression for use with string generation.",null,null],[13,"RegexSyntax","","The string passed as the regex was not syntactically valid.",112,null],[13,"UnsupportedRegex","","The regex was syntactically valid, but contains elements not supported by proptest.",112,null],[5,"string_regex","","Creates a strategy which generates strings matching the given regular expression.",null,{"i":[{"n":"str"}],"o":{"g":["regexgeneratorstrategy","error"],"n":"result"}}],[5,"string_regex_parsed","","Like `string_regex()`, but allows providing a pre-parsed expression.",null,{"i":[{"n":"hir"}],"o":{"g":["regexgeneratorstrategy","error"],"n":"result"}}],[5,"bytes_regex","","Creates a strategy which generates byte strings matching the given regular expression.",null,{"i":[{"n":"str"}],"o":{"g":["regexgeneratorstrategy","error"],"n":"result"}}],[5,"bytes_regex_parsed","","Like `bytes_regex()`, but allows providing a pre-parsed expression.",null,{"i":[{"n":"hir"}],"o":{"g":["regexgeneratorstrategy","error"],"n":"result"}}],[11,"fmt","","",112,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"fmt","","",112,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"description","","",112,{"i":[{"n":"self"}],"o":{"n":"str"}}],[11,"cause","","",112,{"i":[{"n":"self"}],"o":{"g":["error"],"n":"option"}}],[11,"from","","",112,{"i":[{"n":"parseerror"}],"o":{"n":"error"}}],[11,"clone","","",113,{"i":[{"n":"self"}],"o":{"n":"stringparam"}}],[11,"eq","","",113,{"i":[{"n":"self"},{"n":"stringparam"}],"o":{"n":"bool"}}],[11,"ne","","",113,{"i":[{"n":"self"},{"n":"stringparam"}],"o":{"n":"bool"}}],[11,"partial_cmp","","",113,{"i":[{"n":"self"},{"n":"stringparam"}],"o":{"g":["ordering"],"n":"option"}}],[11,"lt","","",113,{"i":[{"n":"self"},{"n":"stringparam"}],"o":{"n":"bool"}}],[11,"le","","",113,{"i":[{"n":"self"},{"n":"stringparam"}],"o":{"n":"bool"}}],[11,"gt","","",113,{"i":[{"n":"self"},{"n":"stringparam"}],"o":{"n":"bool"}}],[11,"ge","","",113,{"i":[{"n":"self"},{"n":"stringparam"}],"o":{"n":"bool"}}],[11,"cmp","","",113,{"i":[{"n":"self"},{"n":"stringparam"}],"o":{"n":"ordering"}}],[11,"hash","","",113,null],[11,"from","","",113,{"i":[{"n":"str"}],"o":{"n":"self"}}],[11,"default","","",113,{"o":{"n":"self"}}],[11,"fmt","","",114,{"i":[{"n":"self"},{"n":"formatter"}],"o":{"n":"result"}}],[11,"new_tree","","",114,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"current","","",115,null],[11,"simplify","","",115,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[11,"complicate","","",115,{"i":[{"n":"self"}],"o":{"n":"bool"}}],[0,"prelude","proptest","Re-exports the most commonly-needed APIs of proptest.",null,null],[8,"RngCore","proptest::prelude","The core of a random number generator.",null,null],[10,"next_u32","","Return the next random `u32`.",116,{"i":[{"n":"self"}],"o":{"n":"u32"}}],[10,"next_u64","","Return the next random `u64`.",116,{"i":[{"n":"self"}],"o":{"n":"u64"}}],[10,"fill_bytes","","Fill `dest` with random data.",116,null],[10,"try_fill_bytes","","Fill `dest` entirely with random data.",116,null],[8,"Rng","","An automatically-implemented extension trait on [`RngCore`] providing high-level generic methods for sampling values and other convenience methods.",null,null],[11,"gen","","Return a random value supporting the [`Standard`] distribution.",117,{"i":[{"n":"self"}],"o":{"n":"t"}}],[11,"gen_range","","Generate a random value in the range [`low`, `high`), i.e. inclusive of `low` and exclusive of `high`.",117,{"i":[{"n":"self"},{"n":"t"},{"n":"t"}],"o":{"n":"t"}}],[11,"sample","","Sample a new value, using the given distribution.",117,{"i":[{"n":"self"},{"n":"d"}],"o":{"n":"t"}}],[11,"sample_iter","","Create an iterator that generates values using the given distribution.",117,{"i":[{"n":"self"},{"n":"d"}],"o":{"n":"distiter"}}],[11,"fill","","Fill `dest` entirely with random bytes (uniform value distribution), where `dest` is any type supporting [`AsByteSliceMut`], namely slices and arrays over primitive integer types (`i8`, `i16`, `u32`, etc.).",117,null],[11,"try_fill","","Fill `dest` entirely with random bytes (uniform value distribution), where `dest` is any type supporting [`AsByteSliceMut`], namely slices and arrays over primitive integer types (`i8`, `i16`, `u32`, etc.).",117,{"i":[{"n":"self"},{"n":"t"}],"o":{"g":["error"],"n":"result"}}],[11,"gen_bool","","Return a bool with a probability `p` of being true.",117,{"i":[{"n":"self"},{"n":"f64"}],"o":{"n":"bool"}}],[11,"choose","","Return a random element from `values`.",117,null],[11,"choose_mut","","Return a mutable pointer to a random element from `values`.",117,null],[11,"shuffle","","Shuffle a mutable slice in place.",117,null],[11,"gen_iter","","Return an iterator that will yield an infinite number of randomly generated items.",117,{"i":[{"n":"self"}],"o":{"n":"generator"}}],[11,"gen_weighted_bool","","Return a bool with a 1 in n chance of true",117,{"i":[{"n":"self"},{"n":"u32"}],"o":{"n":"bool"}}],[11,"gen_ascii_chars","","Return an iterator of random characters from the set A-Z,a-z,0-9.",117,{"i":[{"n":"self"}],"o":{"n":"asciigenerator"}}],[3,"BoxedStrategy","","A boxed `Strategy` trait object as produced by `Strategy::boxed()`.",null,null],[3,"Just","","A `Strategy` which always produces a single value value and never simplifies.",null,null],[12,"0","","The value produced by this strategy.",60,null],[3,"SBoxedStrategy","","A boxed `Strategy` trait object which is also `Sync` and `Send`, as produced by `Strategy::sboxed()`.",null,null],[3,"ProptestConfig","","Configuration for how a proptest test should be run.",null,null],[12,"cases","","The number of successful test cases that must execute for the test as a whole to pass.",92,null],[12,"max_local_rejects","","The maximum number of individual inputs that may be rejected before the test as a whole aborts.",92,null],[12,"max_global_rejects","","The maximum number of combined inputs that may be rejected before the test as a whole aborts.",92,null],[12,"max_flat_map_regens","","The maximum number of times all `Flatten` combinators will attempt to regenerate values. This puts a limit on the worst-case exponential explosion that can happen with nested `Flatten`s.",92,null],[12,"failure_persistence","","Indicates whether and how to persist failed test results.",92,null],[12,"source_file","","File location of the current test, relevant for persistence and debugging.",92,null],[12,"test_name","","The fully-qualified name of the test being run, as would be passed to the test executable to run just that test.",92,null],[12,"fork","","If true, tests are run in a subprocess.",92,null],[12,"timeout","","If non-zero, tests are run in a subprocess and each generated case fails if it takes longer than this number of milliseconds.",92,null],[4,"TestCaseError","","Errors which can be returned from test cases to indicate non-successful completion.",null,null],[13,"Reject","","The input was not valid for the test case. This does not count as a test failure (nor a success); rather, it simply signals to generate a new input and try again.",94,null],[13,"Fail","","The code under test failed the test.",94,null],[5,"any","","Generates a [`Strategy`] producing [`Arbitrary`][trait Arbitrary] values of `A`. Unlike [`arbitrary`][fn arbitrary], it should be used for being explicit on what `A` is. For clarity, this may be a good idea.",null,{"o":{"n":"strategyfor"}}],[5,"any_with","","Generates a [`Strategy`] producing [`Arbitrary`] values of `A` with the given configuration arguments passed in `args`. Unlike [`arbitrary_with`], it should be used for being explicit on what `A` is. For clarity, this may be a good idea.",null,{"i":[{"n":"paramsfor"}],"o":{"n":"strategyfor"}}],[0,"prop","","Re-exports the entire public API of proptest so that an import of `prelude` allows simply writing, for example, `prop::num::i32::ANY` rather than `proptest::num::i32::ANY` plus a separate `use proptest;`.",null,null],[8,"Strategy","","A strategy for producing arbitrary values of a given type.",null,null],[16,"Tree","","The value tree generated by this `Strategy`.",88,null],[16,"Value","","The type of value used by functions under test generated by this Strategy.",88,null],[10,"new_tree","","Generate a new value tree from the given runner.",88,{"i":[{"n":"self"},{"n":"testrunner"}],"o":{"n":"newtree"}}],[11,"prop_map","proptest::strategy","Returns a strategy which produces values transformed by the function `fun`.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"map"}}],[11,"prop_map_into","","Returns a strategy which produces values of type `O` by transforming `Self` with `Into<O>`.",88,{"i":[{"n":"self"}],"o":{"n":"mapinto"}}],[11,"prop_perturb","","Returns a strategy which produces values transformed by the function `fun`, which is additionally given a random number generator.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"perturb"}}],[11,"prop_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["map"],"n":"flatten"}}],[11,"prop_ind_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies while considering the new strategies to be independent.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["map"],"n":"indflatten"}}],[11,"prop_ind_flat_map2","","Similar to `prop_ind_flat_map()`, but produces 2-tuples with the input generated from `self` in slot 0 and the derived strategy in slot 1.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"indflattenmap"}}],[11,"prop_filter","","Returns a strategy which only produces values accepted by `fun`.",88,{"i":[{"n":"self"},{"n":"r"},{"n":"f"}],"o":{"n":"filter"}}],[11,"prop_filter_map","","Returns a strategy which only produces transformed values where `fun` returns `Some(value)` and rejects those where `fun` returns `None`.",88,null],[11,"prop_union","","Returns a strategy which picks uniformly from `self` and `other`.",88,{"i":[{"n":"self"},{"n":"self"}],"o":{"n":"union"}}],[11,"prop_recursive","","Generate a recursive structure with `self` items as leaves.",88,{"i":[{"n":"self"},{"n":"u32"},{"n":"u32"},{"n":"u32"},{"n":"f"}],"o":{"n":"recursive"}}],[11,"prop_shuffle","","Shuffle the contents of the values produced by this strategy.",88,{"i":[{"n":"self"}],"o":{"n":"shuffle"}}],[11,"boxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,{"i":[{"n":"self"}],"o":{"n":"boxedstrategy"}}],[11,"sboxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,{"i":[{"n":"self"}],"o":{"n":"sboxedstrategy"}}],[11,"no_shrink","","Wraps this strategy to prevent values from being subject to shrinking.",88,{"i":[{"n":"self"}],"o":{"n":"noshrink"}}],[8,"Arbitrary","proptest::prelude","Arbitrary determines a canonical [`Strategy`] for the implementing type.",null,null],[16,"Parameters","","The type of parameters that [`arbitrary_with`] accepts for configuration of the generated [`Strategy`]. Parameters must implement [`Default`].",2,null],[11,"arbitrary","proptest::arbitrary","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`).",2,null],[10,"arbitrary_with","proptest::prelude","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`). The strategy is passed the arguments given in args.",2,null],[16,"Strategy","","The type of [`Strategy`] used to generate values of type `Self`.",2,null],[14,"proptest","proptest","Easily define `proptest` tests.",null,null],[14,"prop_assume","","Rejects the test input if assumptions are not met.",null,null],[14,"prop_oneof","","Produce a strategy which picks one of the listed choices.",null,null],[14,"prop_compose","","Convenience to define functions which produce new strategies.",null,null],[14,"prop_assert","","Similar to `assert!` from std, but returns a test failure instead of panicking if the condition fails.",null,null],[14,"prop_assert_eq","","Similar to `assert_eq!` from std, but returns a test failure instead of panicking if the condition fails.",null,null],[14,"prop_assert_ne","","Similar to `assert_ne!` from std, but returns a test failure instead of panicking if the condition fails.",null,null],[11,"arbitrary","proptest::arbitrary","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`).",2,null],[11,"arbitrary_with","proptest::option","",101,null],[11,"arbitrary_with","proptest::collection","",14,null],[11,"prop_map","proptest::strategy","Returns a strategy which produces values transformed by the function `fun`.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"map"}}],[11,"prop_map_into","","Returns a strategy which produces values of type `O` by transforming `Self` with `Into<O>`.",88,{"i":[{"n":"self"}],"o":{"n":"mapinto"}}],[11,"prop_perturb","","Returns a strategy which produces values transformed by the function `fun`, which is additionally given a random number generator.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"perturb"}}],[11,"prop_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["map"],"n":"flatten"}}],[11,"prop_ind_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies while considering the new strategies to be independent.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"g":["map"],"n":"indflatten"}}],[11,"prop_ind_flat_map2","","Similar to `prop_ind_flat_map()`, but produces 2-tuples with the input generated from `self` in slot 0 and the derived strategy in slot 1.",88,{"i":[{"n":"self"},{"n":"f"}],"o":{"n":"indflattenmap"}}],[11,"prop_filter","","Returns a strategy which only produces values accepted by `fun`.",88,{"i":[{"n":"self"},{"n":"r"},{"n":"f"}],"o":{"n":"filter"}}],[11,"prop_filter_map","","Returns a strategy which only produces transformed values where `fun` returns `Some(value)` and rejects those where `fun` returns `None`.",88,null],[11,"prop_union","","Returns a strategy which picks uniformly from `self` and `other`.",88,{"i":[{"n":"self"},{"n":"self"}],"o":{"n":"union"}}],[11,"prop_recursive","","Generate a recursive structure with `self` items as leaves.",88,{"i":[{"n":"self"},{"n":"u32"},{"n":"u32"},{"n":"u32"},{"n":"f"}],"o":{"n":"recursive"}}],[11,"prop_shuffle","","Shuffle the contents of the values produced by this strategy.",88,{"i":[{"n":"self"}],"o":{"n":"shuffle"}}],[11,"boxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,{"i":[{"n":"self"}],"o":{"n":"boxedstrategy"}}],[11,"sboxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,{"i":[{"n":"self"}],"o":{"n":"sboxedstrategy"}}],[11,"no_shrink","","Wraps this strategy to prevent values from being subject to shrinking.",88,{"i":[{"n":"self"}],"o":{"n":"noshrink"}}],[11,"read","proptest::prelude","",116,null],[11,"eq","proptest::test_runner","",99,{"i":[{"n":"self"},{"n":"failurepersistence"}],"o":{"n":"bool"}}]],"paths":[[8,"ArbitraryF1"],[8,"ArbitraryF2"],[8,"Arbitrary"],[3,"UniformArrayStrategy"],[3,"ArrayValueTree"],[8,"BitSetLike"],[3,"BitSetStrategy"],[3,"SampledBitSetStrategy"],[3,"BitSetValueTree"],[3,"Any"],[3,"Weighted"],[3,"BoolValueTree"],[3,"CharStrategy"],[3,"CharValueTree"],[3,"SizeRange"],[3,"VecStrategy"],[3,"VecDequeStrategy"],[3,"VecDequeValueTree"],[3,"LinkedListStrategy"],[3,"LinkedListValueTree"],[3,"BinaryHeapStrategy"],[3,"BinaryHeapValueTree"],[3,"HashSetStrategy"],[3,"HashSetValueTree"],[3,"BTreeSetStrategy"],[3,"BTreeSetValueTree"],[3,"HashMapStrategy"],[3,"HashMapValueTree"],[3,"BTreeMapStrategy"],[3,"BTreeMapValueTree"],[3,"VecValueTree"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"CheckStrategySanityOptions"],[3,"Just"],[3,"NoShrink"],[3,"BoxedStrategy"],[3,"SBoxedStrategy"],[3,"LazyJust"],[3,"Map"],[3,"MapInto"],[3,"Perturb"],[3,"PerturbValueTree"],[3,"Filter"],[3,"FilterMap"],[3,"FilterMapValueTree"],[3,"Flatten"],[3,"FlattenValueTree"],[3,"IndFlatten"],[3,"IndFlattenMap"],[3,"Union"],[3,"UnionValueTree"],[3,"TupleUnion"],[3,"TupleUnionValueTree"],[3,"Recursive"],[3,"Shuffle"],[3,"ShuffleValueTree"],[3,"Fuse"],[8,"FilterFn"],[8,"MapFn"],[3,"Filter"],[3,"Map"],[8,"Strategy"],[8,"ValueTree"],[8,"Shuffleable"],[3,"MapFailurePersistence"],[3,"Config"],[4,"FileFailurePersistence"],[4,"TestCaseError"],[4,"TestError"],[3,"TestRng"],[3,"Reason"],[3,"TestRunner"],[8,"FailurePersistence"],[3,"TupleValueTree"],[3,"Probability"],[3,"OptionStrategy"],[3,"OptionValueTree"],[3,"MaybeOk"],[3,"MaybeOkValueTree"],[3,"MaybeErr"],[3,"MaybeErrValueTree"],[3,"Subsequence"],[3,"SubsequenceValueTree"],[3,"Select"],[3,"SelectValueTree"],[4,"Error"],[3,"StringParam"],[3,"RegexGeneratorStrategy"],[3,"RegexGeneratorValueTree"],[8,"RngCore"],[8,"Rng"]]};
initSearch(searchIndex);
