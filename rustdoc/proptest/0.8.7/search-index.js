var N = null;var searchIndex = {};
searchIndex["proptest"]={"doc":"Proptest is a property testing framework (i.e., the QuickCheck family) inspired by the Hypothesis framework for Python. It allows to test that certain properties of your code hold for arbitrary inputs, and if a failure is found, automatically finds the minimal test case to reproduce the problem. Unlike QuickCheck, generation and shrinking is defined on a per-value basis instead of per-type, which makes it more flexible and simplifies composition.","items":[[0,"arbitrary","proptest","Defines the [`Arbitrary`] trait and related free functions and type aliases. See the trait for more information.",N,N],[5,"any","proptest::arbitrary","Generates a [`Strategy`] producing [`Arbitrary`][trait Arbitrary] values of `A`. Unlike [`arbitrary`][fn arbitrary], it should be used for being explicit on what `A` is. For clarity, this may be a good idea.",N,[[],["strategyfor"]]],[5,"any_with","","Generates a [`Strategy`] producing [`Arbitrary`] values of `A` with the given configuration arguments passed in `args`. Unlike [`arbitrary_with`], it should be used for being explicit on what `A` is. For clarity, this may be a good idea.",N,[[["paramsfor"]],["strategyfor"]]],[5,"arbitrary","","Generates a [`Strategy`] producing [`Arbitrary`] values of `A`. Works better with type inference than [`any::<A>()`].",N,[[],["s"]]],[5,"arbitrary_with","","Generates a [`Strategy`] producing [`Arbitrary`] values of `A` with the given configuration arguments passed in `args`. Works better with type inference than [`any_with::<A>(args)`].",N,[[["p"]],["s"]]],[0,"functor","","Provides higher order `Arbitrary` traits. This is mainly for use by `proptest_derive`.",N,N],[8,"ArbitraryF1","proptest::arbitrary::functor","`ArbitraryF1` lets you lift a [`Strategy`] to unary type constructors such as `Box`, `Vec`, and `Option`.",N,N],[16,"Parameters","","The type of parameters that [`lift1_with`] accepts for configuration of the lifted and generated [`Strategy`]. Parameters must implement [`Default`].",0,N],[11,"lift1","","Lifts a given [`Strategy`] to a new [`Strategy`] for the (presumably) bigger type. This is useful for lifting a `Strategy` for `SomeType` to a container such as `Vec<SomeType>`.",0,[[["as"]],["boxedstrategy"]]],[10,"lift1_with","","Lifts a given [`Strategy`] to a new [`Strategy`] for the (presumably) bigger type. This is useful for lifting a `Strategy` for `SomeType` to a container such as `Vec` of `SomeType`. The composite strategy is passed the arguments given in `args`.",0,N],[8,"ArbitraryF2","","`ArbitraryF2` lets you lift [`Strategy`] to binary type constructors such as `Result`, `HashMap`.",N,N],[16,"Parameters","","The type of parameters that [`lift2_with`] accepts for configuration of the lifted and generated [`Strategy`]. Parameters must implement [`Default`].",1,N],[11,"lift2","","Lifts two given strategies to a new [`Strategy`] for the (presumably) bigger type. This is useful for lifting a `Strategy` for `Type1` and one for `Type2` to a container such as `HashMap<Type1, Type2>`.",1,[[["as"],["bs"]],["boxedstrategy"]]],[10,"lift2_with","","Lifts two given strategies to a new [`Strategy`] for the (presumably) bigger type. This is useful for lifting a `Strategy` for `Type1` and one for `Type2` to a container such as `HashMap<Type1, Type2>`. The composite strategy is passed the arguments given in `args`.",1,N],[6,"StrategyFor","proptest::arbitrary","`StrategyFor` allows you to mention the type of [`Strategy`] for the input type `A` without directly using associated types or without resorting to existential types. This way, if implementation of [`Arbitrary`] changes, your tests should not break. This can be especially beneficial when the type of `Strategy` that you are dealing with is very long in name (the case with generics).",N,N],[6,"ParamsFor","","`ParamsFor` allows you to mention the type of [`Parameters`] for the input type `A` without directly using associated types or without resorting to existential types. This way, if implementation of [`Arbitrary`] changes, your tests should not break.",N,N],[6,"SMapped","","A static map from a strategy of `I` to `O`.",N,N],[6,"Mapped","","A normal map from a strategy of `I` to `O`.",N,N],[8,"Arbitrary","","Arbitrary determines a canonical [`Strategy`] for the implementing type.",N,N],[16,"Parameters","","The type of parameters that [`arbitrary_with`] accepts for configuration of the generated [`Strategy`]. Parameters must implement [`Default`].",2,N],[11,"arbitrary","","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`).",2,N],[10,"arbitrary_with","","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`). The strategy is passed the arguments given in args.",2,N],[16,"Strategy","","The type of [`Strategy`] used to generate values of type `Self`.",2,N],[0,"array","proptest","Support for strategies producing fixed-length arrays.",N,N],[3,"UniformArrayStrategy","proptest::array","A `Strategy` which generates fixed-size arrays containing values drawn from an inner strategy.",N,N],[3,"ArrayValueTree","","A `ValueTree` operating over a fixed-size array.",N,N],[5,"uniform1","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform2","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform3","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform4","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform5","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform6","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform7","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform8","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform9","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform10","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform11","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform12","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform13","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform14","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform15","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform16","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform17","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform18","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform19","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform20","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform21","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform22","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform23","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform24","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform25","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform26","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform27","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform28","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform29","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform30","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform31","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[5,"uniform32","","Create a strategy to generate fixed-length arrays.",N,[[["s"]],["uniformarraystrategy"]]],[11,"clone","","",3,[[["self"]],["uniformarraystrategy"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"new","","Directly create a `UniformArrayStrategy`.",3,[[["s"]],["self"]]],[11,"clone","","",4,[[["self"]],["arrayvaluetree"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",4,N],[11,"simplify","","",4,[[["self"]],["bool"]]],[11,"complicate","","",4,[[["self"]],["bool"]]],[0,"bits","proptest","Strategies for working with bit sets.",N,N],[3,"BitSetStrategy","proptest::bits","Generates values as a set of bits between the two bounds.",N,N],[3,"SampledBitSetStrategy","","Generates bit sets with a particular number of bits set.",N,N],[3,"BitSetValueTree","","Value tree produced by `BitSetStrategy` and `SampledBitSetStrategy`.",N,N],[0,"u8","","",N,N],[5,"between","proptest::bits::u8","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["u8"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["u8"]],["bitsetstrategy",["u8"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[17,"ANY","","Generates integers where all bits may be set.",N,N],[0,"u16","proptest::bits","",N,N],[5,"between","proptest::bits::u16","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["u16"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["u16"]],["bitsetstrategy",["u16"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[17,"ANY","","Generates integers where all bits may be set.",N,N],[0,"u32","proptest::bits","",N,N],[5,"between","proptest::bits::u32","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["u32"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["u32"]],["bitsetstrategy",["u32"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[17,"ANY","","Generates integers where all bits may be set.",N,N],[0,"u64","proptest::bits","",N,N],[5,"between","proptest::bits::u64","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["u64"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["u64"]],["bitsetstrategy",["u64"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[17,"ANY","","Generates integers where all bits may be set.",N,N],[0,"i8","proptest::bits","",N,N],[5,"between","proptest::bits::i8","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["i8"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["i8"]],["bitsetstrategy",["i8"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[17,"ANY","","Generates integers where all bits may be set.",N,N],[0,"i16","proptest::bits","",N,N],[5,"between","proptest::bits::i16","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["i16"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["i16"]],["bitsetstrategy",["i16"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[17,"ANY","","Generates integers where all bits may be set.",N,N],[0,"i32","proptest::bits","",N,N],[5,"between","proptest::bits::i32","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["i32"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["i32"]],["bitsetstrategy",["i32"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[17,"ANY","","Generates integers where all bits may be set.",N,N],[0,"i64","proptest::bits","",N,N],[5,"between","proptest::bits::i64","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["i64"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["i64"]],["bitsetstrategy",["i64"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[17,"ANY","","Generates integers where all bits may be set.",N,N],[0,"usize","proptest::bits","",N,N],[5,"between","proptest::bits::usize","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["usize"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["usize"]],["bitsetstrategy",["usize"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[0,"isize","proptest::bits","",N,N],[5,"between","proptest::bits::isize","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["isize"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["isize"]],["bitsetstrategy",["isize"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[0,"bitset","proptest::bits","",N,N],[5,"between","proptest::bits::bitset","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["bitset"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["bitset"]],["bitsetstrategy",["bitset"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[0,"bool_vec","proptest::bits","",N,N],[5,"between","proptest::bits::bool_vec","Generates values where bits between the given bounds may be set.",N,[[["usize"],["usize"]],["bitsetstrategy",["vec"]]]],[5,"masked","","Generates values where any bits set in `mask` (and no others) may be set.",N,[[["vec",["bool"]]],["bitsetstrategy",["vec"]]]],[5,"sampled","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",N,N],[8,"BitSetLike","proptest::bits","Trait for types which can be handled with `BitSetStrategy`.",N,N],[10,"new_bitset","","Create a new value of `Self` with space for up to `max` bits, all initialised to zero.",5,[[["usize"]],["self"]]],[10,"len","","Return an upper bound on the greatest bit set plus one.",5,[[["self"]],["usize"]]],[10,"test","","Test whether the given bit is set.",5,[[["self"],["usize"]],["bool"]]],[10,"set","","Set the given bit.",5,[[["self"],["usize"]]]],[10,"clear","","Clear the given bit.",5,[[["self"],["usize"]]]],[11,"count","","Return the number of bits set.",5,[[["self"]],["usize"]]],[11,"clone","","",6,[[["self"]],["bitsetstrategy"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a strategy which generates values where bits between `min` (inclusive) and `max` (exclusive) may be set.",6,[[["usize"],["usize"]],["self"]]],[11,"masked","","Create a strategy which generates values where any bits set (and only those bits) in `mask` may be set.",6,[[["t"]],["self"]]],[11,"new_tree","","",6,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",7,[[["self"]],["sampledbitsetstrategy"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a strategy which generates values where bits within the bounds given by `bits` may be set. The number of bits that are set is chosen to be in the range given by `size`.",7,N],[11,"new_tree","","",7,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",8,[[["self"]],["bitsetvaluetree"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"current","","",8,[[["self"]],["t"]]],[11,"simplify","","",8,[[["self"]],["bool"]]],[11,"complicate","","",8,[[["self"]],["bool"]]],[0,"bool","proptest","Strategies for generating `bool` values.",N,N],[3,"Any","proptest::bool","The type of the `ANY` constant.",N,N],[3,"Weighted","","The return type from `weighted()`.",N,N],[3,"BoolValueTree","","The `ValueTree` to shrink booleans to false.",N,N],[5,"weighted","","Generates boolean values by picking `true` with the given `probability` (1.0 = always true, 0.0 = always false).",N,[[["f64"]],["weighted"]]],[17,"ANY","","Generates boolean values by picking `true` or `false` uniformly.",N,N],[11,"clone","","",9,[[["self"]],["any"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",9,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",10,[[["self"]],["weighted"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",10,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",11,[[["self"]],["boolvaluetree"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"current","","",11,[[["self"]],["bool"]]],[11,"simplify","","",11,[[["self"]],["bool"]]],[11,"complicate","","",11,[[["self"]],["bool"]]],[0,"char","proptest","Strategies for generating `char` values.",N,N],[3,"CharStrategy","proptest::char","Strategy for generating `char`s.",N,N],[3,"CharValueTree","","The `ValueTree` corresponding to `CharStrategy`.",N,N],[5,"select_char","","Selects a random character the way `CharStrategy` does.",N,N],[5,"any","","Creates a `CharStrategy` which picks from literally any character, with the default biases.",N,[[],["charstrategy"]]],[5,"range","","Creates a `CharStrategy` which selects characters within the given endpoints, inclusive, using the default biases.",N,[[["char"],["char"]],["charstrategy"]]],[5,"ranges","","Creates a `CharStrategy` which selects characters within the given ranges, all inclusive, using the default biases.",N,[[["cow"]],["charstrategy"]]],[17,"DEFAULT_SPECIAL_CHARS","","A default set of characters to consider as \"special\" during character generation.",N,N],[17,"DEFAULT_PREFERRED_RANGES","","A default sequence of ranges used preferentially when generating random characters.",N,N],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"clone","","",12,[[["self"]],["charstrategy"]]],[11,"new","","Construct a new `CharStrategy` with the parameters it will pass to the function underlying `select_char()`.",12,[[["cow"],["cow"],["cow"]],["self"]]],[11,"new_borrowed","","Same as `CharStrategy::new()` but using `Cow::Borrowed` for all parts.",12,N],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"clone","","",13,[[["self"]],["charvaluetree"]]],[11,"new_tree","","",12,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",13,[[["self"]],["char"]]],[11,"simplify","","",13,[[["self"]],["bool"]]],[11,"complicate","","",13,[[["self"]],["bool"]]],[0,"collection","proptest","Strategies for generating `std::collections` of values.",N,N],[3,"SizeRange","proptest::collection","The minimum and maximum range/bounds on the size of a collection. The interval must form a subset of `[0, std::usize::MAX)`.",N,N],[3,"VecStrategy","","Strategy to create `Vec`s with a length in a certain range.",N,N],[3,"VecDequeStrategy","","Strategy to create `VecDeque`s with a length in a certain range.",N,N],[3,"VecDequeValueTree","","`ValueTree` corresponding to `VecDequeStrategy`.",N,N],[3,"LinkedListStrategy","","Strategy to create `LinkedList`s with a length in a certain range.",N,N],[3,"LinkedListValueTree","","`ValueTree` corresponding to `LinkedListStrategy`.",N,N],[3,"BinaryHeapStrategy","","Strategy to create `BinaryHeap`s with a length in a certain range.",N,N],[3,"BinaryHeapValueTree","","`ValueTree` corresponding to `BinaryHeapStrategy`.",N,N],[3,"HashSetStrategy","","Strategy to create `HashSet`s with a length in a certain range.",N,N],[3,"HashSetValueTree","","`ValueTree` corresponding to `HashSetStrategy`.",N,N],[3,"BTreeSetStrategy","","Strategy to create `BTreeSet`s with a length in a certain range.",N,N],[3,"BTreeSetValueTree","","`ValueTree` corresponding to `BTreeSetStrategy`.",N,N],[3,"HashMapStrategy","","Strategy to create `HashMap`s with a length in a certain range.",N,N],[3,"HashMapValueTree","","`ValueTree` corresponding to `HashMapStrategy`.",N,N],[3,"BTreeMapStrategy","","Strategy to create `BTreeMap`s with a length in a certain range.",N,N],[3,"BTreeMapValueTree","","`ValueTree` corresponding to `BTreeMapStrategy`.",N,N],[3,"VecValueTree","","`ValueTree` corresponding to `VecStrategy`.",N,N],[5,"size_range","","Creates a `SizeRange` from some value that is convertible into it.",N,N],[5,"vec","","Create a strategy to generate `Vec`s containing elements drawn from `element` and with a size range given by `size`.",N,N],[5,"vec_deque","","Create a strategy to generate `VecDeque`s containing elements drawn from `element` and with a size range given by `size`.",N,N],[5,"linked_list","","Create a strategy to generate `LinkedList`s containing elements drawn from `element` and with a size range given by `size`.",N,N],[5,"binary_heap","","Create a strategy to generate `BinaryHeap`s containing elements drawn from `element` and with a size range given by `size`.",N,N],[5,"hash_set","","Create a strategy to generate `HashSet`s containing elements drawn from `element` and with a size range given by `size`.",N,N],[5,"btree_set","","Create a strategy to generate `BTreeSet`s containing elements drawn from `element` and with a size range given by `size`.",N,N],[5,"hash_map","","Create a strategy to generate `HashMap`s containing keys and values drawn from `key` and `value` respectively, and with a size within the given range.",N,N],[5,"btree_map","","Create a strategy to generate `BTreeMap`s containing keys and values drawn from `key` and `value` respectively, and with a size within the given range.",N,N],[11,"clone","","",14,[[["self"]],["sizerange"]]],[11,"eq","","",14,[[["self"],["sizerange"]],["bool"]]],[11,"ne","","",14,[[["self"],["sizerange"]],["bool"]]],[11,"hash","","",14,N],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"default","","Constructs a `SizeRange` equivalent to `size_range(0..100)`.",14,[[],["self"]]],[11,"new","","Creates a `SizeBounds` from a `RangeInclusive<usize>`.",14,[[["rangeinclusive",["usize"]]],["self"]]],[11,"with","","Merges self together with some other argument producing a product type expected by some impelementations of `A: Arbitrary` in `A::Parameters`. This can be more ergonomic to work with and may help type inference.",14,N],[11,"lift","","Merges self together with some other argument generated with a default value producing a product type expected by some impelementations of `A: Arbitrary` in `A::Parameters`. This can be more ergonomic to work with and may help type inference.",14,N],[11,"from","","",14,N],[11,"from","","",14,[[["usize"]],["self"]]],[11,"from","","",14,[[["rangeto",["usize"]]],["self"]]],[11,"from","","",14,[[["range",["usize"]]],["self"]]],[11,"from","","",14,[[["rangeinclusive",["usize"]]],["self"]]],[11,"from","","",14,[[["rangetoinclusive",["usize"]]],["self"]]],[11,"add","","",14,N],[11,"clone","","",15,[[["self"]],["vecstrategy"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"clone","","",16,[[["self"]],["vecdequestrategy"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"clone","","",17,[[["self"]],["vecdequevaluetree"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",16,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",17,N],[11,"simplify","","",17,[[["self"]],["bool"]]],[11,"complicate","","",17,[[["self"]],["bool"]]],[11,"clone","","",18,[[["self"]],["linkedliststrategy"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"clone","","",19,[[["self"]],["linkedlistvaluetree"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",18,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",19,N],[11,"simplify","","",19,[[["self"]],["bool"]]],[11,"complicate","","",19,[[["self"]],["bool"]]],[11,"clone","","",20,[[["self"]],["binaryheapstrategy"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"clone","","",21,[[["self"]],["binaryheapvaluetree"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",20,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",21,N],[11,"simplify","","",21,[[["self"]],["bool"]]],[11,"complicate","","",21,[[["self"]],["bool"]]],[11,"clone","","",22,[[["self"]],["hashsetstrategy"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"clone","","",23,[[["self"]],["hashsetvaluetree"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",22,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",23,N],[11,"simplify","","",23,[[["self"]],["bool"]]],[11,"complicate","","",23,[[["self"]],["bool"]]],[11,"clone","","",24,[[["self"]],["btreesetstrategy"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"clone","","",25,[[["self"]],["btreesetvaluetree"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",24,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",25,N],[11,"simplify","","",25,[[["self"]],["bool"]]],[11,"complicate","","",25,[[["self"]],["bool"]]],[11,"clone","","",26,[[["self"]],["hashmapstrategy"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"clone","","",27,[[["self"]],["hashmapvaluetree"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",26,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",27,N],[11,"simplify","","",27,[[["self"]],["bool"]]],[11,"complicate","","",27,[[["self"]],["bool"]]],[11,"clone","","",28,[[["self"]],["btreemapstrategy"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"clone","","",29,[[["self"]],["btreemapvaluetree"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",28,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",29,N],[11,"simplify","","",29,[[["self"]],["bool"]]],[11,"complicate","","",29,[[["self"]],["bool"]]],[11,"clone","","",30,[[["self"]],["vecvaluetree"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",15,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",30,[[["self"]],["vec"]]],[11,"simplify","","",30,[[["self"]],["bool"]]],[11,"complicate","","",30,[[["self"]],["bool"]]],[0,"num","proptest","Strategies to generate numeric values (as opposed to integers used as bit fields).",N,N],[0,"i8","proptest::num","",N,N],[3,"Any","proptest::num::i8","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",31,[[["self"]],["any"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",31,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",32,[[["self"]],["binarysearch"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",32,[[["i8"]],["self"]]],[11,"current","","",32,[[["self"]],["i8"]]],[11,"simplify","","",32,[[["self"]],["bool"]]],[11,"complicate","","",32,[[["self"]],["bool"]]],[0,"i16","proptest::num","",N,N],[3,"Any","proptest::num::i16","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",33,[[["self"]],["any"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",33,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",34,[[["self"]],["binarysearch"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",34,[[["i16"]],["self"]]],[11,"current","","",34,[[["self"]],["i16"]]],[11,"simplify","","",34,[[["self"]],["bool"]]],[11,"complicate","","",34,[[["self"]],["bool"]]],[0,"i32","proptest::num","",N,N],[3,"Any","proptest::num::i32","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",35,[[["self"]],["any"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",35,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",36,[[["self"]],["binarysearch"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",36,[[["i32"]],["self"]]],[11,"current","","",36,[[["self"]],["i32"]]],[11,"simplify","","",36,[[["self"]],["bool"]]],[11,"complicate","","",36,[[["self"]],["bool"]]],[0,"i64","proptest::num","",N,N],[3,"Any","proptest::num::i64","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",37,[[["self"]],["any"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",37,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",38,[[["self"]],["binarysearch"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",38,[[["i64"]],["self"]]],[11,"current","","",38,[[["self"]],["i64"]]],[11,"simplify","","",38,[[["self"]],["bool"]]],[11,"complicate","","",38,[[["self"]],["bool"]]],[0,"i128","proptest::num","",N,N],[3,"Any","proptest::num::i128","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",39,[[["self"]],["any"]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",39,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",40,[[["self"]],["binarysearch"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",40,[[["i128"]],["self"]]],[11,"current","","",40,[[["self"]],["i128"]]],[11,"simplify","","",40,[[["self"]],["bool"]]],[11,"complicate","","",40,[[["self"]],["bool"]]],[0,"isize","proptest::num","",N,N],[3,"Any","proptest::num::isize","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",41,[[["self"]],["any"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",41,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",42,[[["self"]],["binarysearch"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",42,[[["isize"]],["self"]]],[11,"current","","",42,[[["self"]],["isize"]]],[11,"simplify","","",42,[[["self"]],["bool"]]],[11,"complicate","","",42,[[["self"]],["bool"]]],[0,"u8","proptest::num","",N,N],[3,"Any","proptest::num::u8","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",43,[[["self"]],["any"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",43,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",44,[[["self"]],["binarysearch"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",44,[[["u8"]],["self"]]],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",44,[[["u8"],["u8"]],["self"]]],[11,"current","","",44,[[["self"]],["u8"]]],[11,"simplify","","",44,[[["self"]],["bool"]]],[11,"complicate","","",44,[[["self"]],["bool"]]],[0,"u16","proptest::num","",N,N],[3,"Any","proptest::num::u16","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",45,[[["self"]],["any"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",45,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",46,[[["self"]],["binarysearch"]]],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",46,[[["u16"]],["self"]]],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",46,[[["u16"],["u16"]],["self"]]],[11,"current","","",46,[[["self"]],["u16"]]],[11,"simplify","","",46,[[["self"]],["bool"]]],[11,"complicate","","",46,[[["self"]],["bool"]]],[0,"u32","proptest::num","",N,N],[3,"Any","proptest::num::u32","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",47,[[["self"]],["any"]]],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",47,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",48,[[["self"]],["binarysearch"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",48,[[["u32"]],["self"]]],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",48,[[["u32"],["u32"]],["self"]]],[11,"current","","",48,[[["self"]],["u32"]]],[11,"simplify","","",48,[[["self"]],["bool"]]],[11,"complicate","","",48,[[["self"]],["bool"]]],[0,"u64","proptest::num","",N,N],[3,"Any","proptest::num::u64","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",49,[[["self"]],["any"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",49,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",50,[[["self"]],["binarysearch"]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",50,[[["u64"]],["self"]]],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",50,[[["u64"],["u64"]],["self"]]],[11,"current","","",50,[[["self"]],["u64"]]],[11,"simplify","","",50,[[["self"]],["bool"]]],[11,"complicate","","",50,[[["self"]],["bool"]]],[0,"u128","proptest::num","",N,N],[3,"Any","proptest::num::u128","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",51,[[["self"]],["any"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",51,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",52,[[["self"]],["binarysearch"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",52,[[["u128"]],["self"]]],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",52,[[["u128"],["u128"]],["self"]]],[11,"current","","",52,[[["self"]],["u128"]]],[11,"simplify","","",52,[[["self"]],["bool"]]],[11,"complicate","","",52,[[["self"]],["bool"]]],[0,"usize","proptest::num","",N,N],[3,"Any","proptest::num::usize","Type of the `ANY` constant.",N,N],[3,"BinarySearch","","Shrinks an integer towards 0, using binary search to find boundary points.",N,N],[17,"ANY","","Generates integers with completely arbitrary values, uniformly distributed over the whole range.",N,N],[11,"clone","","",53,[[["self"]],["any"]]],[11,"fmt","","",53,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",53,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",54,[[["self"]],["binarysearch"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",54,[[["usize"]],["self"]]],[11,"new_above","","Creates a new binary searcher which will not search below the given `lo` value.",54,[[["usize"],["usize"]],["self"]]],[11,"current","","",54,[[["self"]],["usize"]]],[11,"simplify","","",54,[[["self"]],["bool"]]],[11,"complicate","","",54,[[["self"]],["bool"]]],[0,"f32","proptest::num","",N,N],[3,"Any","proptest::num::f32","Strategies which produce floating-point values from particular classes. See the various `Any`-typed constants in this module.",N,N],[3,"BinarySearch","","Shrinks a float towards 0, using binary search to find boundary points.",N,N],[17,"POSITIVE","","Generates positive floats",N,N],[17,"NEGATIVE","","Generates negative floats.",N,N],[17,"NORMAL","","Generates \"normal\" floats.",N,N],[17,"SUBNORMAL","","Generates subnormal floats.",N,N],[17,"ZERO","","Generates zero-valued floats.",N,N],[17,"INFINITE","","Generates infinity floats.",N,N],[17,"QUIET_NAN","","Generates \"Quiet NaN\" floats.",N,N],[17,"SIGNALING_NAN","","Generates \"Signaling NaN\" floats if allowed by the platform.",N,N],[17,"ANY","","Generates literally arbitrary floating-point values, including infinities and quiet NaNs (but not signaling NaNs).",N,N],[11,"clone","","",55,[[["self"]],["any"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"bitor","","",55,[[["self"],["self"]],["self"]]],[11,"bitor_assign","","",55,[[["self"],["self"]]]],[11,"new_tree","","",55,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",56,[[["self"]],["binarysearch"]]],[11,"fmt","","",56,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",56,[[["f32"]],["self"]]],[11,"current","","",56,[[["self"]],["f32"]]],[11,"simplify","","",56,[[["self"]],["bool"]]],[11,"complicate","","",56,[[["self"]],["bool"]]],[0,"f64","proptest::num","",N,N],[3,"Any","proptest::num::f64","Strategies which produce floating-point values from particular classes. See the various `Any`-typed constants in this module.",N,N],[3,"BinarySearch","","Shrinks a float towards 0, using binary search to find boundary points.",N,N],[17,"POSITIVE","","Generates positive floats",N,N],[17,"NEGATIVE","","Generates negative floats.",N,N],[17,"NORMAL","","Generates \"normal\" floats.",N,N],[17,"SUBNORMAL","","Generates subnormal floats.",N,N],[17,"ZERO","","Generates zero-valued floats.",N,N],[17,"INFINITE","","Generates infinity floats.",N,N],[17,"QUIET_NAN","","Generates \"Quiet NaN\" floats.",N,N],[17,"SIGNALING_NAN","","Generates \"Signaling NaN\" floats if allowed by the platform.",N,N],[17,"ANY","","Generates literally arbitrary floating-point values, including infinities and quiet NaNs (but not signaling NaNs).",N,N],[11,"clone","","",57,[[["self"]],["any"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"bitor","","",57,[[["self"],["self"]],["self"]]],[11,"bitor_assign","","",57,[[["self"],["self"]]]],[11,"new_tree","","",57,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",58,[[["self"]],["binarysearch"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new binary searcher starting at the given value.",58,[[["f64"]],["self"]]],[11,"current","","",58,[[["self"]],["f64"]]],[11,"simplify","","",58,[[["self"]],["bool"]]],[11,"complicate","","",58,[[["self"]],["bool"]]],[0,"strategy","proptest","Defines the core traits used by Proptest.",N,N],[3,"NoShrink","proptest::strategy","Wraps a `Strategy` or `ValueTree` to suppress shrinking of generated values.",N,N],[3,"BoxedStrategy","","A boxed `Strategy` trait object as produced by `Strategy::boxed()`.",N,N],[3,"SBoxedStrategy","","A boxed `Strategy` trait object which is also `Sync` and `Send`, as produced by `Strategy::sboxed()`.",N,N],[3,"CheckStrategySanityOptions","","Options passed to `check_strategy_sanity()`.",N,N],[12,"strict_complicate_after_simplify","","If true (the default), require that `complicate()` return `true` at least once after any call to `simplify()` which itself returns once.",59,N],[3,"Just","","A `Strategy` which always produces a single value value and never simplifies.",N,N],[12,"0","","The value produced by this strategy.",60,N],[3,"LazyJust","","A `Strategy` which always produces a single value value and never simplifies. If `T` is `Clone`, you should use `Just` instead.",N,N],[3,"Map","","`Strategy` and `ValueTree` map adaptor.",N,N],[3,"MapInto","","`Strategy` and `ValueTree` map into adaptor.",N,N],[3,"Perturb","","`Strategy` perturbation adaptor.",N,N],[3,"PerturbValueTree","","`ValueTree` perturbation adaptor.",N,N],[3,"Filter","","`Strategy` and `ValueTree` filter adaptor.",N,N],[3,"FilterMap","","`Strategy` and `ValueTree` filter_map adaptor.",N,N],[3,"FilterMapValueTree","","`ValueTree` corresponding to `FilterMap`.",N,N],[3,"Flatten","","Adaptor that flattens a `Strategy` which produces other `Strategy`s into a `Strategy` that picks one of those strategies and then picks values from it.",N,N],[3,"FlattenValueTree","","The `ValueTree` produced by `Flatten`.",N,N],[3,"IndFlatten","","Similar to `Flatten`, but does not shrink the input strategy.",N,N],[3,"IndFlattenMap","","Similar to `Map` plus `Flatten`, but does not shrink the input strategy and passes the original input through.",N,N],[3,"Union","","A `Strategy` which picks from one of several delegate `Stragegy`s.",N,N],[3,"UnionValueTree","","`ValueTree` corresponding to `Union`.",N,N],[3,"TupleUnion","","Similar to `Union`, but internally uses a tuple to hold the strategies.",N,N],[3,"TupleUnionValueTree","","`ValueTree` type produced by `TupleUnion`.",N,N],[3,"Recursive","","Return type from `Strategy::prop_recursive()`.",N,N],[3,"Shuffle","","`Strategy` shuffle adaptor.",N,N],[3,"ShuffleValueTree","","`ValueTree` shuffling adaptor.",N,N],[3,"Fuse","","Adaptor for `Strategy` and `ValueTree` which guards `simplify()` and `complicate()` to avoid contract violations.",N,N],[5,"check_strategy_sanity","","Run some tests on the given `Strategy` to ensure that it upholds the simplify/complicate contracts.",N,[[["s"],["option",["checkstrategysanityoptions"]]]]],[5,"float_to_weight","","Convert a floating-point weight in the range (0.0,1.0) to a pair of weights that can be used with `Union` and similar.",N,N],[11,"clone","","",61,[[["self"]],["noshrink"]]],[11,"fmt","","",61,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",61,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",61,N],[11,"simplify","","",61,[[["self"]],["bool"]]],[11,"complicate","","",61,[[["self"]],["bool"]]],[11,"fmt","","",62,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",63,[[["self"],["formatter"]],["result"]]],[11,"clone","","",62,[[["self"]],["self"]]],[11,"clone","","",63,[[["self"]],["self"]]],[11,"new_tree","","",62,[[["self"],["testrunner"]],["newtree"]]],[11,"boxed","","",62,[[["self"]],["boxedstrategy"]]],[11,"new_tree","","",63,[[["self"],["testrunner"]],["newtree"]]],[11,"sboxed","","",63,[[["self"]],["sboxedstrategy"]]],[11,"boxed","","",63,[[["self"]],["boxedstrategy"]]],[11,"clone","","",59,[[["self"]],["checkstrategysanityoptions"]]],[11,"fmt","","",59,[[["self"],["formatter"]],["result"]]],[11,"default","","",59,[[],["self"]]],[11,"clone","","",60,[[["self"]],["just"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",60,[[["self"],["testrunner"]],["newtree"]]],[11,"simplify","","",60,[[["self"]],["bool"]]],[11,"complicate","","",60,[[["self"]],["bool"]]],[11,"current","","",60,[[["self"]],["t"]]],[11,"new","","Constructs a `LazyJust` strategy given the function/closure that produces the value.",64,[[["f"]],["self"]]],[11,"new_tree","","",64,[[["self"],["testrunner"]],["newtree"]]],[11,"simplify","","",64,[[["self"]],["bool"]]],[11,"complicate","","",64,[[["self"]],["bool"]]],[11,"current","","",64,N],[11,"clone","","",64,[[["self"]],["self"]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",65,[[["self"],["formatter"]],["result"]]],[11,"clone","","",65,[[["self"]],["self"]]],[11,"new_tree","","",65,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",65,[[["self"]],["o"]]],[11,"simplify","","",65,[[["self"]],["bool"]]],[11,"complicate","","",65,[[["self"]],["bool"]]],[11,"fmt","","",66,[[["self"],["formatter"]],["result"]]],[11,"clone","","",66,[[["self"]],["self"]]],[11,"new_tree","","",66,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",66,[[["self"]],["o"]]],[11,"simplify","","",66,[[["self"]],["bool"]]],[11,"complicate","","",66,[[["self"]],["bool"]]],[11,"fmt","","",67,[[["self"],["formatter"]],["result"]]],[11,"clone","","",67,[[["self"]],["self"]]],[11,"new_tree","","",67,[[["self"],["testrunner"]],["newtree"]]],[11,"fmt","","",68,[[["self"],["formatter"]],["result"]]],[11,"clone","","",68,[[["self"]],["self"]]],[11,"current","","",68,[[["self"]],["o"]]],[11,"simplify","","",68,[[["self"]],["bool"]]],[11,"complicate","","",68,[[["self"]],["bool"]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result"]]],[11,"clone","","",69,[[["self"]],["self"]]],[11,"new_tree","","",69,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",69,N],[11,"simplify","","",69,[[["self"]],["bool"]]],[11,"complicate","","",69,[[["self"]],["bool"]]],[11,"fmt","","",70,[[["self"],["formatter"]],["result"]]],[11,"clone","","",70,[[["self"]],["self"]]],[11,"new_tree","","",70,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",71,[[["self"]],["self"]]],[11,"fmt","","",71,[[["self"],["formatter"]],["result"]]],[11,"current","","",71,[[["self"]],["o"]]],[11,"simplify","","",71,[[["self"]],["bool"]]],[11,"complicate","","",71,[[["self"]],["bool"]]],[11,"fmt","","",72,[[["self"],["formatter"]],["result"]]],[11,"clone","","",72,[[["self"]],["flatten"]]],[11,"new","","Wrap `source` to flatten it.",72,[[["s"]],["self"]]],[11,"new_tree","","",72,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",73,[[["self"]],["self"]]],[11,"fmt","","",73,[[["self"],["formatter"]],["result"]]],[11,"current","","",73,N],[11,"simplify","","",73,[[["self"]],["bool"]]],[11,"complicate","","",73,[[["self"]],["bool"]]],[11,"clone","","",74,[[["self"]],["indflatten"]]],[11,"fmt","","",74,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",74,[[["self"],["testrunner"]],["newtree"]]],[11,"fmt","","",75,[[["self"],["formatter"]],["result"]]],[11,"clone","","",75,[[["self"]],["self"]]],[11,"new_tree","","",75,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",76,[[["self"]],["union"]]],[11,"fmt","","",76,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a strategy which selects uniformly from the given delegate strategies.",76,N],[11,"new_weighted","","Create a strategy which selects from the given delegate strategies.",76,[[["vec",["w"]]],["self"]]],[11,"or","","Add `other` as an additional alternate strategy with weight 1.",76,[[["self"],["t"]],["self"]]],[11,"new_tree","","",76,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",77,[[["self"]],["unionvaluetree"]]],[11,"fmt","","",77,[[["self"],["formatter"]],["result"]]],[11,"current","","",77,N],[11,"simplify","","",77,[[["self"]],["bool"]]],[11,"complicate","","",77,[[["self"]],["bool"]]],[11,"clone","","",78,[[["self"]],["tupleunion"]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"new","","Wrap `tuple` in a `TupleUnion`.",78,[[["t"]],["self"]]],[11,"new_tree","","",78,[[["self"],["testrunner"]],["newtree"]]],[11,"new_tree","","",78,[[["self"],["testrunner"]],["newtree"]]],[11,"new_tree","","",78,[[["self"],["testrunner"]],["newtree"]]],[11,"new_tree","","",78,[[["self"],["testrunner"]],["newtree"]]],[11,"new_tree","","",78,[[["self"],["testrunner"]],["newtree"]]],[11,"new_tree","","",78,[[["self"],["testrunner"]],["newtree"]]],[11,"new_tree","","",78,[[["self"],["testrunner"]],["newtree"]]],[11,"new_tree","","",78,[[["self"],["testrunner"]],["newtree"]]],[11,"new_tree","","",78,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",79,[[["self"]],["tupleunionvaluetree"]]],[11,"fmt","","",79,[[["self"],["formatter"]],["result"]]],[11,"current","","",79,N],[11,"simplify","","",79,[[["self"]],["bool"]]],[11,"complicate","","",79,[[["self"]],["bool"]]],[11,"current","","",79,N],[11,"simplify","","",79,[[["self"]],["bool"]]],[11,"complicate","","",79,[[["self"]],["bool"]]],[11,"current","","",79,N],[11,"simplify","","",79,[[["self"]],["bool"]]],[11,"complicate","","",79,[[["self"]],["bool"]]],[11,"current","","",79,N],[11,"simplify","","",79,[[["self"]],["bool"]]],[11,"complicate","","",79,[[["self"]],["bool"]]],[11,"current","","",79,N],[11,"simplify","","",79,[[["self"]],["bool"]]],[11,"complicate","","",79,[[["self"]],["bool"]]],[11,"current","","",79,N],[11,"simplify","","",79,[[["self"]],["bool"]]],[11,"complicate","","",79,[[["self"]],["bool"]]],[11,"current","","",79,N],[11,"simplify","","",79,[[["self"]],["bool"]]],[11,"complicate","","",79,[[["self"]],["bool"]]],[11,"current","","",79,N],[11,"simplify","","",79,[[["self"]],["bool"]]],[11,"complicate","","",79,[[["self"]],["bool"]]],[11,"current","","",79,N],[11,"simplify","","",79,[[["self"]],["bool"]]],[11,"complicate","","",79,[[["self"]],["bool"]]],[11,"fmt","","",80,[[["self"],["formatter"]],["result"]]],[11,"clone","","",80,[[["self"]],["self"]]],[11,"new_tree","","",80,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",81,[[["self"]],["shuffle"]]],[11,"fmt","","",81,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",81,[[["self"],["testrunner"]],["newtree"]]],[11,"clone","","",82,[[["self"]],["shufflevaluetree"]]],[11,"fmt","","",82,[[["self"],["formatter"]],["result"]]],[11,"current","","",82,N],[11,"simplify","","",82,[[["self"]],["bool"]]],[11,"complicate","","",82,[[["self"]],["bool"]]],[11,"fmt","","",83,[[["self"],["formatter"]],["result"]]],[11,"clone","","",83,[[["self"]],["fuse"]]],[11,"new","","Wrap the given `T` in `Fuse`.",83,[[["t"]],["self"]]],[11,"new_tree","","",83,[[["self"],["testrunner"]],["newtree"]]],[11,"may_simplify","","Return whether a call to `simplify()` may be productive.",83,[[["self"]],["bool"]]],[11,"disallow_simplify","","Disallow any further calls to `simplify()` until a call to `complicate()` returns `true`.",83,[[["self"]]]],[11,"may_complicate","","Return whether a call to `complicate()` may be productive.",83,[[["self"]],["bool"]]],[11,"disallow_complicate","","Disallow any further calls to `complicate()` until a call to `simplify()` returns `true`.",83,[[["self"]]]],[11,"freeze","","Prevent any further shrinking operations from occurring.",83,[[["self"]]]],[11,"current","","",83,N],[11,"simplify","","",83,[[["self"]],["bool"]]],[11,"complicate","","",83,[[["self"]],["bool"]]],[0,"statics","","Modified versions of the normal strategy combinators which take specialised traits instead of normal functions.",N,N],[3,"Filter","proptest::strategy::statics","Static version of `strategy::Filter`.",N,N],[3,"Map","","Static version of `strategy::Map`.",N,N],[8,"FilterFn","","Essentially `Fn (&T) -> bool`.",N,N],[10,"apply","","Test whether `t` passes the filter.",84,[[["self"],["t"]],["bool"]]],[8,"MapFn","","Essentially `Fn (T) -> Output`.",N,N],[16,"Output","","",85,N],[10,"apply","","Map `T` to `Output`.",85,N],[11,"clone","","",86,[[["self"]],["filter"]]],[11,"new","","Adapt strategy `source` to reject values which do not pass `filter`, using `whence` as the reported reason/location.",86,[[["s"],["reason"],["f"]],["self"]]],[11,"fmt","","",86,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",86,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",86,N],[11,"simplify","","",86,[[["self"]],["bool"]]],[11,"complicate","","",86,[[["self"]],["bool"]]],[11,"clone","","",87,[[["self"]],["map"]]],[11,"new","","Adapt strategy `source` by applying `fun` to values it produces.",87,[[["s"],["f"]],["self"]]],[11,"fmt","","",87,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",87,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",87,N],[11,"simplify","","",87,[[["self"]],["bool"]]],[11,"complicate","","",87,[[["self"]],["bool"]]],[6,"NewTree","proptest::strategy","A new [`ValueTree`] from a [`Strategy`] when [`Ok`] or otherwise [`Err`] when a new value-tree can not be produced for some reason such as in the case of filtering with a predicate which always returns false. You should pass in your strategy as the type parameter.",N,N],[6,"ValueFor","","The value that functions under test use for a particular `Strategy`.",N,N],[6,"LazyJustFn","","Shorthand for `LazyJust<T, fn () -> T>`.",N,N],[6,"W","","A relative `weight` of a particular `Strategy` corresponding to `T` coupled with `T` itself. The weight is currently given in `u32`.",N,N],[8,"Strategy","","A strategy for producing arbitrary values of a given type.",N,N],[16,"Tree","","The value tree generated by this `Strategy`.",88,N],[16,"Value","","The type of value used by functions under test generated by this Strategy.",88,N],[10,"new_tree","","Generate a new value tree from the given runner.",88,[[["self"],["testrunner"]],["newtree"]]],[11,"prop_map","","Returns a strategy which produces values transformed by the function `fun`.",88,[[["self"],["f"]],["map"]]],[11,"prop_map_into","","Returns a strategy which produces values of type `O` by transforming `Self` with `Into<O>`.",88,[[["self"]],["mapinto"]]],[11,"prop_perturb","","Returns a strategy which produces values transformed by the function `fun`, which is additionally given a random number generator.",88,[[["self"],["f"]],["perturb"]]],[11,"prop_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies.",88,[[["self"],["f"]],["flatten",["map"]]]],[11,"prop_ind_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies while considering the new strategies to be independent.",88,[[["self"],["f"]],["indflatten",["map"]]]],[11,"prop_ind_flat_map2","","Similar to `prop_ind_flat_map()`, but produces 2-tuples with the input generated from `self` in slot 0 and the derived strategy in slot 1.",88,[[["self"],["f"]],["indflattenmap"]]],[11,"prop_filter","","Returns a strategy which only produces values accepted by `fun`.",88,[[["self"],["r"],["f"]],["filter"]]],[11,"prop_filter_map","","Returns a strategy which only produces transformed values where `fun` returns `Some(value)` and rejects those where `fun` returns `None`.",88,N],[11,"prop_union","","Returns a strategy which picks uniformly from `self` and `other`.",88,[[["self"],["self"]],["union"]]],[11,"prop_recursive","","Generate a recursive structure with `self` items as leaves.",88,[[["self"],["u32"],["u32"],["u32"],["f"]],["recursive"]]],[11,"prop_shuffle","","Shuffle the contents of the values produced by this strategy.",88,[[["self"]],["shuffle"]]],[11,"boxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,[[["self"]],["boxedstrategy"]]],[11,"sboxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,[[["self"]],["sboxedstrategy"]]],[11,"no_shrink","","Wraps this strategy to prevent values from being subject to shrinking.",88,[[["self"]],["noshrink"]]],[8,"ValueTree","","A generated value and its associated shrinker.",N,N],[16,"Value","","The type of the value produced by this `ValueTree`.",89,N],[10,"current","","Returns the current value.",89,N],[10,"simplify","","Attempts to simplify the current value. Notionally, this sets the \"high\" value to the current value, and the current value to a \"halfway point\" between high and low, rounding towards low.",89,[[["self"]],["bool"]]],[10,"complicate","","Attempts to partially undo the last simplification. Notionally, this sets the \"low\" value to one plus the current value, and the current value to a \"halfway point\" between high and the new low, rounding towards low.",89,[[["self"]],["bool"]]],[8,"Shuffleable","","A value which can be used with the `prop_shuffle` combinator.",N,N],[10,"shuffle_len","","Return the length of this collection.",90,[[["self"]],["usize"]]],[10,"shuffle_swap","","Swap the elements at the given indices.",90,[[["self"],["usize"],["usize"]]]],[0,"test_runner","proptest","State and functions for running proptest tests.",N,N],[3,"TestRng","proptest::test_runner","Proptest's random number generator.",N,N],[3,"MapFailurePersistence","","Failure persistence option that loads and saves seeds in memory on the heap. This may be useful when accumulating test failures across multiple `TestRunner` instances for external reporting or batched persistence.",N,N],[12,"map","","Backing map, keyed by source_file.",91,N],[3,"ResultCacheKey","","A key used for the result cache.",N,N],[3,"Config","","Configuration for how a proptest test should be run.",N,N],[12,"cases","","The number of successful test cases that must execute for the test as a whole to pass.",92,N],[12,"max_local_rejects","","The maximum number of individual inputs that may be rejected before the test as a whole aborts.",92,N],[12,"max_global_rejects","","The maximum number of combined inputs that may be rejected before the test as a whole aborts.",92,N],[12,"max_flat_map_regens","","The maximum number of times all `Flatten` combinators will attempt to regenerate values. This puts a limit on the worst-case exponential explosion that can happen with nested `Flatten`s.",92,N],[12,"failure_persistence","","Indicates whether and how to persist failed test results.",92,N],[12,"source_file","","File location of the current test, relevant for persistence and debugging.",92,N],[12,"test_name","","The fully-qualified name of the test being run, as would be passed to the test executable to run just that test.",92,N],[12,"fork","","If true, tests are run in a subprocess.",92,N],[12,"timeout","","If non-zero, tests are run in a subprocess and each generated case fails if it takes longer than this number of milliseconds.",92,N],[12,"max_shrink_time","","If non-zero, give up the shrinking process after this many milliseconds have elapsed since the start of the shrinking process.",92,N],[12,"max_shrink_iters","","Give up on shrinking if more than this number of iterations of the test code are run.",92,N],[12,"result_cache","","A function to create new result caches.",92,N],[12,"verbose","","Set to non-zero values to cause proptest to emit human-targeted messages to stderr as it runs.",92,N],[3,"Reason","","The reason for why something, such as a generated value, was rejected.",N,N],[3,"TestRunner","","State used when running a proptest test.",N,N],[4,"FileFailurePersistence","","Describes how failing test cases are persisted.",N,N],[13,"Off","","Completely disables persistence of failing test cases.",93,N],[13,"SourceParallel","","The path given to `TestRunner::set_source_file()` is parsed. The path is traversed up the directory tree until a directory containing a file named `lib.rs` or `main.rs` is found. A sibling to that directory with the name given by the string in this configuration is created, and a file with the same name and path relative to the source directory, but with the extension changed to `.txt`, is used.",93,N],[13,"WithSource","","The path given to `TestRunner::set_source_file()` is parsed. The extension of the path is changed to the string given in this configuration, and that filename is used.",93,N],[13,"Direct","","The string given in this option is directly used as a file path without any further processing.",93,N],[4,"TestCaseError","","Errors which can be returned from test cases to indicate non-successful completion.",N,N],[13,"Reject","","The input was not valid for the test case. This does not count as a test failure (nor a success); rather, it simply signals to generate a new input and try again.",94,N],[13,"Fail","","The code under test failed the test.",94,N],[4,"TestError","","A failure state from running test cases for a single test.",N,N],[13,"Abort","","The test was aborted for the given reason, for example, due to too many inputs having been rejected.",95,N],[13,"Fail","","A failing test case was found. The string indicates where and/or why the test failed. The `T` is the minimal input found to reproduce the failure.",95,N],[5,"basic_result_cache","","A basic result cache.",N,[[],["box",["resultcache"]]]],[5,"noop_result_cache","","A result cache that does nothing.",N,[[],["box",["resultcache"]]]],[11,"clone","","",96,[[["self"]],["testrng"]]],[11,"fmt","","",96,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",96,[[["self"]],["u32"]]],[11,"next_u64","","",96,[[["self"]],["u64"]]],[11,"fill_bytes","","",96,N],[11,"try_fill_bytes","","",96,N],[11,"clone","","",93,[[["self"]],["filefailurepersistence"]]],[11,"fmt","","",93,[[["self"],["formatter"]],["result"]]],[11,"eq","","",93,[[["self"],["filefailurepersistence"]],["bool"]]],[11,"ne","","",93,[[["self"],["filefailurepersistence"]],["bool"]]],[11,"default","","",93,[[],["self"]]],[11,"load_persisted_failures","","",93,[[["self"],["option",["str"]]],["vec"]]],[11,"save_persisted_failure","","",93,N],[11,"box_clone","","",93,[[["self"]],["box",["failurepersistence"]]]],[11,"eq","","",93,[[["self"],["failurepersistence"]],["bool"]]],[11,"as_any","","",93,[[["self"]],["any"]]],[11,"clone","","",91,[[["self"]],["mapfailurepersistence"]]],[11,"fmt","","",91,[[["self"],["formatter"]],["result"]]],[11,"default","","",91,[[],["mapfailurepersistence"]]],[11,"eq","","",91,[[["self"],["mapfailurepersistence"]],["bool"]]],[11,"ne","","",91,[[["self"],["mapfailurepersistence"]],["bool"]]],[11,"load_persisted_failures","","",91,[[["self"],["option",["str"]]],["vec"]]],[11,"save_persisted_failure","","",91,N],[11,"box_clone","","",91,[[["self"]],["box",["failurepersistence"]]]],[11,"eq","","",91,[[["self"],["failurepersistence"]],["bool"]]],[11,"as_any","","",91,[[["self"]],["any"]]],[11,"fmt","","",97,[[["self"],["formatter"]],["result"]]],[11,"value_debug","","Return the test input value as an `&dyn Debug`.",97,[[["self"]],["debug"]]],[11,"clone","","",92,[[["self"]],["config"]]],[11,"fmt","","",92,[[["self"],["formatter"]],["result"]]],[11,"eq","","",92,[[["self"],["config"]],["bool"]]],[11,"ne","","",92,[[["self"],["config"]],["bool"]]],[11,"with_cases","","Constructs a `Config` only differing from the `default()` in the number of test cases required to pass the test successfully.",92,[[["u32"]],["self"]]],[11,"with_source_file","","Constructs a `Config` only differing from the `default()` in the source_file of the present test.",92,[[["str"]],["self"]]],[11,"clone_with_source_file","","Constructs a `Config` only differing from the provided Config instance, `self`, in the source_file of the present test.",92,[[["self"],["str"]],["self"]]],[11,"fork","","Return whether this configuration implies forking.",92,[[["self"]],["bool"]]],[11,"timeout","","Returns the configured timeout.",92,[[["self"]],["u32"]]],[11,"default","","",92,[[],["self"]]],[11,"fmt","","",98,[[["self"],["formatter"]],["result"]]],[11,"clone","","",98,[[["self"]],["reason"]]],[11,"eq","","",98,[[["self"],["reason"]],["bool"]]],[11,"ne","","",98,[[["self"],["reason"]],["bool"]]],[11,"partial_cmp","","",98,[[["self"],["reason"]],["option",["ordering"]]]],[11,"lt","","",98,[[["self"],["reason"]],["bool"]]],[11,"le","","",98,[[["self"],["reason"]],["bool"]]],[11,"gt","","",98,[[["self"],["reason"]],["bool"]]],[11,"ge","","",98,[[["self"],["reason"]],["bool"]]],[11,"cmp","","",98,[[["self"],["reason"]],["ordering"]]],[11,"hash","","",98,N],[11,"message","","Return the message for this `Reason`.",98,[[["self"]],["str"]]],[11,"from","","",98,[[["str"]],["self"]]],[11,"from","","",98,[[["string"]],["self"]]],[11,"from","","",98,[[["box",["str"]]],["self"]]],[11,"fmt","","",98,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",94,[[["self"],["formatter"]],["result"]]],[11,"clone","","",94,[[["self"]],["testcaseerror"]]],[11,"reject","","Rejects the generated test input as invalid for this test case. This does not count as a test failure (nor a success); rather, it simply signals to generate a new input and try again.",94,N],[11,"fail","","The code under test failed the test.",94,N],[11,"fmt","","",94,[[["self"],["formatter"]],["result"]]],[11,"from","","",94,[[["e"]],["self"]]],[11,"fmt","","",95,[[["self"],["formatter"]],["result"]]],[11,"clone","","",95,[[["self"]],["testerror"]]],[11,"eq","","",95,[[["self"],["testerror"]],["bool"]]],[11,"ne","","",95,[[["self"],["testerror"]],["bool"]]],[11,"fmt","","",95,[[["self"],["formatter"]],["result"]]],[11,"description","","",95,[[["self"]],["str"]]],[11,"clone","","",99,[[["self"]],["testrunner"]]],[11,"fmt","","",99,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",99,[[["self"],["formatter"]],["result"]]],[11,"default","","",99,[[],["self"]]],[11,"new","","Create a fresh `TestRunner` with the given configuration.",99,[[["config"]],["self"]]],[11,"rng","","Returns the RNG for this test run.",99,[[["self"]],["testrng"]]],[11,"new_rng","","Create a new, independent but deterministic RNG from the RNG in this runner.",99,[[["self"]],["testrng"]]],[11,"config","","Returns the configuration of this runner.",99,[[["self"]],["config"]]],[11,"run","","Run test cases against `f`, choosing inputs via `strategy`.",99,N],[11,"run_one","","Run one specific test case against this runner.",99,N],[11,"reject_local","","Update the state to account for a local rejection from `whence`, and return `Ok` if the caller should keep going or `Err` to abort.",99,N],[11,"flat_map_regen","","Increment the counter of flat map regenerations and return whether it is still under the configured limit.",99,[[["self"]],["bool"]]],[6,"TestCaseResult","","Convenience for the type returned by test cases.",N,N],[8,"FailurePersistence","","Provides external persistence for historical test failures by storing seeds.",N,N],[10,"load_persisted_failures","","Supply seeds associated with the given `source_file` that may be used by a `TestRunner`'s random number generator in order to consistently recreate a previously-failing `Strategy`-provided value.",100,[[["self"],["option",["str"]]],["vec"]]],[10,"save_persisted_failure","","Store a new failure-generating seed associated with the given `source_file`.",100,N],[10,"box_clone","","Delegate method for producing a trait object usable with `Clone`",100,[[["self"]],["box",["failurepersistence"]]]],[10,"eq","","Equality testing delegate required due to constraints of trait objects.",100,[[["self"],["failurepersistence"]],["bool"]]],[10,"as_any","","Assistant method for trait object comparison.",100,[[["self"]],["any"]]],[8,"ResultCache","","An object which can cache the outcomes of tests.",N,N],[10,"key","","Convert the given cache key into a `u64` representing that value. The u64 is used as the key below.",101,[[["self"],["resultcachekey"]],["u64"]]],[10,"put","","Save `result` as the outcome associated with the test input in `key`.",101,[[["self"],["u64"],["testcaseresult"]]]],[10,"get","","If `put()` has been called with a semantically equivalent `key`, return the saved result. Otherwise, return `None`.",101,[[["self"],["u64"]],["option",["testcaseresult"]]]],[0,"tuple","proptest","Support for combining strategies into tuples.",N,N],[3,"TupleValueTree","proptest::tuple","Common `ValueTree` implementation for all tuple strategies.",N,N],[11,"clone","","",102,[[["self"]],["tuplevaluetree"]]],[11,"fmt","","",102,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `TupleValueTree` wrapping `inner`.",102,[[["t"]],["self"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[11,"current","","",102,N],[11,"simplify","","",102,[[["self"]],["bool"]]],[11,"complicate","","",102,[[["self"]],["bool"]]],[0,"option","proptest","Strategies for generating `std::Option` values.",N,N],[3,"Probability","proptest::option","A probability in the range `[0.0, 1.0]` with a default of `0.5`.",N,N],[3,"OptionStrategy","","Strategy which generates `Option` values whose inner `Some` values are generated by another strategy.",N,N],[3,"OptionValueTree","","`ValueTree` type corresponding to `OptionStrategy`.",N,N],[5,"prob","","Creates a `Probability` from some value that is convertible into it.",N,N],[5,"of","","Return a strategy producing `Optional` values wrapping values from the given delegate strategy.",N,[[["t"]],["optionstrategy"]]],[5,"weighted","","Return a strategy producing `Optional` values wrapping values from the given delegate strategy.",N,N],[11,"default","","The default probability is 0.5, or 50% chance.",103,[[],["self"]]],[11,"from","","Creates a `Probability` from a `f64`.",103,[[["f64"]],["self"]]],[11,"new","","Creates a `Probability` from a `f64`.",103,[[["f64"]],["self"]]],[11,"with","","Merges self together with some other argument producing a product type expected by some impelementations of `A: Arbitrary` in `A::Parameters`. This can be more ergonomic to work with and may help type inference.",103,N],[11,"lift","","Merges self together with some other argument generated with a default value producing a product type expected by some impelementations of `A: Arbitrary` in `A::Parameters`. This can be more ergonomic to work with and may help type inference.",103,N],[11,"clone","","",103,[[["self"]],["probability"]]],[11,"eq","","",103,[[["self"],["probability"]],["bool"]]],[11,"ne","","",103,[[["self"],["probability"]],["bool"]]],[11,"fmt","","",103,[[["self"],["formatter"]],["result"]]],[11,"clone","","",104,[[["self"]],["optionstrategy"]]],[11,"clone","","",105,[[["self"]],["optionvaluetree"]]],[11,"fmt","","",105,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",104,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",105,N],[11,"simplify","","",105,[[["self"]],["bool"]]],[11,"complicate","","",105,[[["self"]],["bool"]]],[11,"fmt","","",104,[[["self"],["formatter"]],["result"]]],[0,"result","proptest","Strategies for combining delegate strategies into `std::Result`s.",N,N],[3,"MaybeOk","proptest::result","Strategy which generates `Result`s using `Ok` and `Err` values from two delegate strategies.",N,N],[3,"MaybeOkValueTree","","`ValueTree` type corresponding to `MaybeOk`.",N,N],[3,"MaybeErr","","Strategy which generates `Result`s using `Ok` and `Err` values from two delegate strategies.",N,N],[3,"MaybeErrValueTree","","`ValueTree` type corresponding to `MaybeErr`.",N,N],[5,"maybe_ok","","Create a strategy for `Result`s where `Ok` values are taken from `t` and `Err` values are taken from `e`.",N,[[["t"],["e"]],["maybeok"]]],[5,"maybe_ok_weighted","","Create a strategy for `Result`s where `Ok` values are taken from `t` and `Err` values are taken from `e`.",N,N],[5,"maybe_err","","Create a strategy for `Result`s where `Ok` values are taken from `t` and `Err` values are taken from `e`.",N,[[["t"],["e"]],["maybeerr"]]],[5,"maybe_err_weighted","","Create a strategy for `Result`s where `Ok` values are taken from `t` and `Err` values are taken from `e`.",N,N],[11,"clone","","",106,[[["self"]],["maybeok"]]],[11,"clone","","",107,[[["self"]],["maybeokvaluetree"]]],[11,"fmt","","",107,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",106,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",107,N],[11,"simplify","","",107,[[["self"]],["bool"]]],[11,"complicate","","",107,[[["self"]],["bool"]]],[11,"clone","","",108,[[["self"]],["maybeerr"]]],[11,"clone","","",109,[[["self"]],["maybeerrvaluetree"]]],[11,"fmt","","",109,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",108,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",109,N],[11,"simplify","","",109,[[["self"]],["bool"]]],[11,"complicate","","",109,[[["self"]],["bool"]]],[11,"fmt","","",106,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",108,[[["self"],["formatter"]],["result"]]],[0,"sample","proptest","Strategies for generating values by taking samples of collections.",N,N],[3,"Subsequence","proptest::sample","Strategy to generate `Vec`s by sampling a subsequence from another collection.",N,N],[3,"SubsequenceValueTree","","`ValueTree` type for `Subsequence`.",N,N],[3,"Select","","Strategy to produce one value from a fixed collection of options.",N,N],[3,"SelectValueTree","","`ValueTree` corresponding to `Select`.",N,N],[3,"Index","","A stand-in for an index into a slice or similar collection or conceptually similar things.",N,N],[3,"IndexStrategy","","Strategy to create `Index`es.",N,N],[3,"IndexValueTree","","`ValueTree` corresponding to `IndexStrategy`.",N,N],[3,"Selector","","A value for picking random values out of iterators.",N,N],[3,"SelectorStrategy","","Strategy to create `Selector`s.",N,N],[3,"SelectorValueTree","","`ValueTree` corresponding to `SelectorStrategy`.",N,N],[5,"subsequence","","Sample subsequences whose size are within `size` from the given collection `values`.",N,N],[5,"select","","Create a strategy which uniformly selects one value from `values`.",N,N],[11,"fmt","","",110,[[["self"],["formatter"]],["result"]]],[11,"clone","","",110,[[["self"]],["subsequence"]]],[11,"new_tree","","",110,[[["self"],["testrunner"]],["newtree"]]],[11,"fmt","","",111,[[["self"],["formatter"]],["result"]]],[11,"clone","","",111,[[["self"]],["subsequencevaluetree"]]],[11,"current","","",111,N],[11,"simplify","","",111,[[["self"]],["bool"]]],[11,"complicate","","",111,[[["self"]],["bool"]]],[11,"clone","","",112,[[["self"]],["select"]]],[11,"fmt","","",112,[[["self"],["formatter"]],["result"]]],[11,"clone","","",113,[[["self"]],["selectvaluetree"]]],[11,"fmt","","",113,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",112,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",113,N],[11,"simplify","","",113,[[["self"]],["bool"]]],[11,"complicate","","",113,[[["self"]],["bool"]]],[11,"clone","","",114,[[["self"]],["index"]]],[11,"fmt","","",114,[[["self"],["formatter"]],["result"]]],[11,"index","","Return the real index that would be used to index a collection of size `size`.",114,[[["self"],["usize"]],["usize"]]],[11,"get","","Return a reference to the element in `slice` that this `Index` refers to.",114,N],[11,"get_mut","","Return a mutable reference to the element in `slice` that this `Index` refers to.",114,N],[11,"clone","","",115,[[["self"]],["indexstrategy"]]],[11,"fmt","","",115,[[["self"],["formatter"]],["result"]]],[11,"clone","","",116,[[["self"]],["indexvaluetree"]]],[11,"fmt","","",116,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",115,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",116,N],[11,"simplify","","",116,[[["self"]],["bool"]]],[11,"complicate","","",116,[[["self"]],["bool"]]],[11,"clone","","",117,[[["self"]],["selector"]]],[11,"fmt","","",117,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",118,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",119,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",118,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",119,[[["self"]],["selector"]]],[11,"simplify","","",119,[[["self"]],["bool"]]],[11,"complicate","","",119,[[["self"]],["bool"]]],[11,"select","","Pick a random element from iterable `it`.",117,N],[11,"try_select","","Pick a random element from iterable `it`.",117,[[["self"],["t"]],["option"]]],[0,"string","proptest","Strategies for generating strings and byte strings from regular expressions.",N,N],[3,"StringParam","proptest::string","Wraps the regex that forms the `Strategy` for `String` so that a sensible `Default` can be given. The default is a string of non-control characters.",N,N],[3,"RegexGeneratorStrategy","","Strategy which generates values (i.e., `String` or `Vec<u8>`) matching a regular expression.",N,N],[3,"RegexGeneratorValueTree","","`ValueTree` corresponding to `RegexGeneratorStrategy`.",N,N],[4,"Error","","Errors which may occur when preparing a regular expression for use with string generation.",N,N],[13,"RegexSyntax","","The string passed as the regex was not syntactically valid.",120,N],[13,"UnsupportedRegex","","The regex was syntactically valid, but contains elements not supported by proptest.",120,N],[5,"string_regex","","Creates a strategy which generates strings matching the given regular expression.",N,[[["str"]],["result",["regexgeneratorstrategy","error"]]]],[5,"string_regex_parsed","","Like `string_regex()`, but allows providing a pre-parsed expression.",N,[[["hir"]],["result",["regexgeneratorstrategy","error"]]]],[5,"bytes_regex","","Creates a strategy which generates byte strings matching the given regular expression.",N,[[["str"]],["result",["regexgeneratorstrategy","error"]]]],[5,"bytes_regex_parsed","","Like `bytes_regex()`, but allows providing a pre-parsed expression.",N,[[["hir"]],["result",["regexgeneratorstrategy","error"]]]],[11,"fmt","","",120,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",120,[[["self"],["formatter"]],["result"]]],[11,"description","","",120,[[["self"]],["str"]]],[11,"cause","","",120,[[["self"]],["option",["error"]]]],[11,"from","","",120,[[["parseerror"]],["error"]]],[11,"clone","","",121,[[["self"]],["stringparam"]]],[11,"eq","","",121,[[["self"],["stringparam"]],["bool"]]],[11,"ne","","",121,[[["self"],["stringparam"]],["bool"]]],[11,"partial_cmp","","",121,[[["self"],["stringparam"]],["option",["ordering"]]]],[11,"lt","","",121,[[["self"],["stringparam"]],["bool"]]],[11,"le","","",121,[[["self"],["stringparam"]],["bool"]]],[11,"gt","","",121,[[["self"],["stringparam"]],["bool"]]],[11,"ge","","",121,[[["self"],["stringparam"]],["bool"]]],[11,"cmp","","",121,[[["self"],["stringparam"]],["ordering"]]],[11,"hash","","",121,N],[11,"from","","",121,[[["str"]],["self"]]],[11,"default","","",121,[[],["self"]]],[11,"fmt","","",122,[[["self"],["formatter"]],["result"]]],[11,"new_tree","","",122,[[["self"],["testrunner"]],["newtree"]]],[11,"current","","",123,N],[11,"simplify","","",123,[[["self"]],["bool"]]],[11,"complicate","","",123,[[["self"]],["bool"]]],[0,"prelude","proptest","Re-exports the most commonly-needed APIs of proptest.",N,N],[8,"RngCore","proptest::prelude","The core of a random number generator.",N,N],[10,"next_u32","","Return the next random `u32`.",124,[[["self"]],["u32"]]],[10,"next_u64","","Return the next random `u64`.",124,[[["self"]],["u64"]]],[10,"fill_bytes","","Fill `dest` with random data.",124,N],[10,"try_fill_bytes","","Fill `dest` entirely with random data.",124,N],[8,"Rng","","An automatically-implemented extension trait on [`RngCore`] providing high-level generic methods for sampling values and other convenience methods.",N,N],[11,"gen","","Return a random value supporting the [`Standard`] distribution.",125,[[["self"]],["t"]]],[11,"gen_range","","Generate a random value in the range [`low`, `high`), i.e. inclusive of `low` and exclusive of `high`.",125,[[["self"],["t"],["t"]],["t"]]],[11,"sample","","Sample a new value, using the given distribution.",125,[[["self"],["d"]],["t"]]],[11,"sample_iter","","Create an iterator that generates values using the given distribution.",125,[[["self"],["d"]],["distiter"]]],[11,"fill","","Fill `dest` entirely with random bytes (uniform value distribution), where `dest` is any type supporting [`AsByteSliceMut`], namely slices and arrays over primitive integer types (`i8`, `i16`, `u32`, etc.).",125,N],[11,"try_fill","","Fill `dest` entirely with random bytes (uniform value distribution), where `dest` is any type supporting [`AsByteSliceMut`], namely slices and arrays over primitive integer types (`i8`, `i16`, `u32`, etc.).",125,[[["self"],["t"]],["result",["error"]]]],[11,"gen_bool","","Return a bool with a probability `p` of being true.",125,[[["self"],["f64"]],["bool"]]],[11,"choose","","Return a random element from `values`.",125,N],[11,"choose_mut","","Return a mutable pointer to a random element from `values`.",125,N],[11,"shuffle","","Shuffle a mutable slice in place.",125,N],[11,"gen_iter","","Return an iterator that will yield an infinite number of randomly generated items.",125,[[["self"]],["generator"]]],[11,"gen_weighted_bool","","Return a bool with a 1 in n chance of true",125,[[["self"],["u32"]],["bool"]]],[11,"gen_ascii_chars","","Return an iterator of random characters from the set A-Z,a-z,0-9.",125,[[["self"]],["asciigenerator"]]],[3,"BoxedStrategy","","A boxed `Strategy` trait object as produced by `Strategy::boxed()`.",N,N],[3,"Just","","A `Strategy` which always produces a single value value and never simplifies.",N,N],[12,"0","","The value produced by this strategy.",60,N],[3,"SBoxedStrategy","","A boxed `Strategy` trait object which is also `Sync` and `Send`, as produced by `Strategy::sboxed()`.",N,N],[3,"ProptestConfig","","Configuration for how a proptest test should be run.",N,N],[12,"cases","","The number of successful test cases that must execute for the test as a whole to pass.",92,N],[12,"max_local_rejects","","The maximum number of individual inputs that may be rejected before the test as a whole aborts.",92,N],[12,"max_global_rejects","","The maximum number of combined inputs that may be rejected before the test as a whole aborts.",92,N],[12,"max_flat_map_regens","","The maximum number of times all `Flatten` combinators will attempt to regenerate values. This puts a limit on the worst-case exponential explosion that can happen with nested `Flatten`s.",92,N],[12,"failure_persistence","","Indicates whether and how to persist failed test results.",92,N],[12,"source_file","","File location of the current test, relevant for persistence and debugging.",92,N],[12,"test_name","","The fully-qualified name of the test being run, as would be passed to the test executable to run just that test.",92,N],[12,"fork","","If true, tests are run in a subprocess.",92,N],[12,"timeout","","If non-zero, tests are run in a subprocess and each generated case fails if it takes longer than this number of milliseconds.",92,N],[12,"max_shrink_time","","If non-zero, give up the shrinking process after this many milliseconds have elapsed since the start of the shrinking process.",92,N],[12,"max_shrink_iters","","Give up on shrinking if more than this number of iterations of the test code are run.",92,N],[12,"result_cache","","A function to create new result caches.",92,N],[12,"verbose","","Set to non-zero values to cause proptest to emit human-targeted messages to stderr as it runs.",92,N],[4,"TestCaseError","","Errors which can be returned from test cases to indicate non-successful completion.",N,N],[13,"Reject","","The input was not valid for the test case. This does not count as a test failure (nor a success); rather, it simply signals to generate a new input and try again.",94,N],[13,"Fail","","The code under test failed the test.",94,N],[5,"any","","Generates a [`Strategy`] producing [`Arbitrary`][trait Arbitrary] values of `A`. Unlike [`arbitrary`][fn arbitrary], it should be used for being explicit on what `A` is. For clarity, this may be a good idea.",N,[[],["strategyfor"]]],[5,"any_with","","Generates a [`Strategy`] producing [`Arbitrary`] values of `A` with the given configuration arguments passed in `args`. Unlike [`arbitrary_with`], it should be used for being explicit on what `A` is. For clarity, this may be a good idea.",N,[[["paramsfor"]],["strategyfor"]]],[0,"prop","","Re-exports the entire public API of proptest so that an import of `prelude` allows simply writing, for example, `prop::num::i32::ANY` rather than `proptest::num::i32::ANY` plus a separate `use proptest;`.",N,N],[8,"Strategy","","A strategy for producing arbitrary values of a given type.",N,N],[16,"Tree","","The value tree generated by this `Strategy`.",88,N],[16,"Value","","The type of value used by functions under test generated by this Strategy.",88,N],[10,"new_tree","","Generate a new value tree from the given runner.",88,[[["self"],["testrunner"]],["newtree"]]],[11,"prop_map","proptest::strategy","Returns a strategy which produces values transformed by the function `fun`.",88,[[["self"],["f"]],["map"]]],[11,"prop_map_into","","Returns a strategy which produces values of type `O` by transforming `Self` with `Into<O>`.",88,[[["self"]],["mapinto"]]],[11,"prop_perturb","","Returns a strategy which produces values transformed by the function `fun`, which is additionally given a random number generator.",88,[[["self"],["f"]],["perturb"]]],[11,"prop_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies.",88,[[["self"],["f"]],["flatten",["map"]]]],[11,"prop_ind_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies while considering the new strategies to be independent.",88,[[["self"],["f"]],["indflatten",["map"]]]],[11,"prop_ind_flat_map2","","Similar to `prop_ind_flat_map()`, but produces 2-tuples with the input generated from `self` in slot 0 and the derived strategy in slot 1.",88,[[["self"],["f"]],["indflattenmap"]]],[11,"prop_filter","","Returns a strategy which only produces values accepted by `fun`.",88,[[["self"],["r"],["f"]],["filter"]]],[11,"prop_filter_map","","Returns a strategy which only produces transformed values where `fun` returns `Some(value)` and rejects those where `fun` returns `None`.",88,N],[11,"prop_union","","Returns a strategy which picks uniformly from `self` and `other`.",88,[[["self"],["self"]],["union"]]],[11,"prop_recursive","","Generate a recursive structure with `self` items as leaves.",88,[[["self"],["u32"],["u32"],["u32"],["f"]],["recursive"]]],[11,"prop_shuffle","","Shuffle the contents of the values produced by this strategy.",88,[[["self"]],["shuffle"]]],[11,"boxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,[[["self"]],["boxedstrategy"]]],[11,"sboxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,[[["self"]],["sboxedstrategy"]]],[11,"no_shrink","","Wraps this strategy to prevent values from being subject to shrinking.",88,[[["self"]],["noshrink"]]],[8,"Arbitrary","proptest::prelude","Arbitrary determines a canonical [`Strategy`] for the implementing type.",N,N],[16,"Parameters","","The type of parameters that [`arbitrary_with`] accepts for configuration of the generated [`Strategy`]. Parameters must implement [`Default`].",2,N],[11,"arbitrary","proptest::arbitrary","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`).",2,N],[10,"arbitrary_with","proptest::prelude","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`). The strategy is passed the arguments given in args.",2,N],[16,"Strategy","","The type of [`Strategy`] used to generate values of type `Self`.",2,N],[14,"proptest","proptest","Easily define `proptest` tests.",N,N],[14,"prop_assume","","Rejects the test input if assumptions are not met.",N,N],[14,"prop_oneof","","Produce a strategy which picks one of the listed choices.",N,N],[14,"prop_compose","","Convenience to define functions which produce new strategies.",N,N],[14,"prop_assert","","Similar to `assert!` from std, but returns a test failure instead of panicking if the condition fails.",N,N],[14,"prop_assert_eq","","Similar to `assert_eq!` from std, but returns a test failure instead of panicking if the condition fails.",N,N],[14,"prop_assert_ne","","Similar to `assert_ne!` from std, but returns a test failure instead of panicking if the condition fails.",N,N],[11,"arbitrary","proptest::arbitrary","Generates a [`Strategy`] for producing arbitrary values of type the implementing type (`Self`).",2,N],[11,"arbitrary_with","proptest::sample","",114,N],[11,"arbitrary_with","","",117,N],[11,"arbitrary_with","proptest::option","",103,N],[11,"arbitrary_with","proptest::collection","",14,N],[11,"prop_map","proptest::strategy","Returns a strategy which produces values transformed by the function `fun`.",88,[[["self"],["f"]],["map"]]],[11,"prop_map_into","","Returns a strategy which produces values of type `O` by transforming `Self` with `Into<O>`.",88,[[["self"]],["mapinto"]]],[11,"prop_perturb","","Returns a strategy which produces values transformed by the function `fun`, which is additionally given a random number generator.",88,[[["self"],["f"]],["perturb"]]],[11,"prop_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies.",88,[[["self"],["f"]],["flatten",["map"]]]],[11,"prop_ind_flat_map","","Maps values produced by this strategy into new strategies and picks values from those strategies while considering the new strategies to be independent.",88,[[["self"],["f"]],["indflatten",["map"]]]],[11,"prop_ind_flat_map2","","Similar to `prop_ind_flat_map()`, but produces 2-tuples with the input generated from `self` in slot 0 and the derived strategy in slot 1.",88,[[["self"],["f"]],["indflattenmap"]]],[11,"prop_filter","","Returns a strategy which only produces values accepted by `fun`.",88,[[["self"],["r"],["f"]],["filter"]]],[11,"prop_filter_map","","Returns a strategy which only produces transformed values where `fun` returns `Some(value)` and rejects those where `fun` returns `None`.",88,N],[11,"prop_union","","Returns a strategy which picks uniformly from `self` and `other`.",88,[[["self"],["self"]],["union"]]],[11,"prop_recursive","","Generate a recursive structure with `self` items as leaves.",88,[[["self"],["u32"],["u32"],["u32"],["f"]],["recursive"]]],[11,"prop_shuffle","","Shuffle the contents of the values produced by this strategy.",88,[[["self"]],["shuffle"]]],[11,"boxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,[[["self"]],["boxedstrategy"]]],[11,"sboxed","","Erases the type of this `Strategy` so it can be passed around as a simple trait object.",88,[[["self"]],["sboxedstrategy"]]],[11,"no_shrink","","Wraps this strategy to prevent values from being subject to shrinking.",88,[[["self"]],["noshrink"]]],[11,"read","proptest::prelude","",124,N],[11,"eq","proptest::test_runner","",100,[[["self"],["failurepersistence"]],["bool"]]]],"paths":[[8,"ArbitraryF1"],[8,"ArbitraryF2"],[8,"Arbitrary"],[3,"UniformArrayStrategy"],[3,"ArrayValueTree"],[8,"BitSetLike"],[3,"BitSetStrategy"],[3,"SampledBitSetStrategy"],[3,"BitSetValueTree"],[3,"Any"],[3,"Weighted"],[3,"BoolValueTree"],[3,"CharStrategy"],[3,"CharValueTree"],[3,"SizeRange"],[3,"VecStrategy"],[3,"VecDequeStrategy"],[3,"VecDequeValueTree"],[3,"LinkedListStrategy"],[3,"LinkedListValueTree"],[3,"BinaryHeapStrategy"],[3,"BinaryHeapValueTree"],[3,"HashSetStrategy"],[3,"HashSetValueTree"],[3,"BTreeSetStrategy"],[3,"BTreeSetValueTree"],[3,"HashMapStrategy"],[3,"HashMapValueTree"],[3,"BTreeMapStrategy"],[3,"BTreeMapValueTree"],[3,"VecValueTree"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"Any"],[3,"BinarySearch"],[3,"CheckStrategySanityOptions"],[3,"Just"],[3,"NoShrink"],[3,"BoxedStrategy"],[3,"SBoxedStrategy"],[3,"LazyJust"],[3,"Map"],[3,"MapInto"],[3,"Perturb"],[3,"PerturbValueTree"],[3,"Filter"],[3,"FilterMap"],[3,"FilterMapValueTree"],[3,"Flatten"],[3,"FlattenValueTree"],[3,"IndFlatten"],[3,"IndFlattenMap"],[3,"Union"],[3,"UnionValueTree"],[3,"TupleUnion"],[3,"TupleUnionValueTree"],[3,"Recursive"],[3,"Shuffle"],[3,"ShuffleValueTree"],[3,"Fuse"],[8,"FilterFn"],[8,"MapFn"],[3,"Filter"],[3,"Map"],[8,"Strategy"],[8,"ValueTree"],[8,"Shuffleable"],[3,"MapFailurePersistence"],[3,"Config"],[4,"FileFailurePersistence"],[4,"TestCaseError"],[4,"TestError"],[3,"TestRng"],[3,"ResultCacheKey"],[3,"Reason"],[3,"TestRunner"],[8,"FailurePersistence"],[8,"ResultCache"],[3,"TupleValueTree"],[3,"Probability"],[3,"OptionStrategy"],[3,"OptionValueTree"],[3,"MaybeOk"],[3,"MaybeOkValueTree"],[3,"MaybeErr"],[3,"MaybeErrValueTree"],[3,"Subsequence"],[3,"SubsequenceValueTree"],[3,"Select"],[3,"SelectValueTree"],[3,"Index"],[3,"IndexStrategy"],[3,"IndexValueTree"],[3,"Selector"],[3,"SelectorStrategy"],[3,"SelectorValueTree"],[4,"Error"],[3,"StringParam"],[3,"RegexGeneratorStrategy"],[3,"RegexGeneratorValueTree"],[8,"RngCore"],[8,"Rng"]]};
initSearch(searchIndex);
